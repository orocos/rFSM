<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title><img src="./rFSM_logo.jpg" width="50%" height="50%" title="rFSM Statecharts" alt="rFSM Statecharts" /@> <br/@><br/@>v1.0-beta3</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="[2011-10-31 Mon]"/>
<meta name="author" content="Markus Klotzbuecher"/>
<meta name="description" content="Documentation of rFSM Statecharts."/>
<meta name="keywords" content="Coordination, Statcharts, Robotics, Real-Time, Lua,"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/stylesheet.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="content">

<h1 class="title"><img src="./rFSM_logo.jpg" width="50%" height="50%" title="rFSM Statecharts" alt="rFSM Statecharts" /@> <br/@><br/@>v1.0-beta3</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Overview </a></li>
<li><a href="#sec-2">2 Setup </a></li>
<li><a href="#sec-3">3 Quickstart </a></li>
<li><a href="#sec-4">4 Introduction </a></li>
<li><a href="#sec-5">5 Specifying rFSM models </a>
<ul>
<li><a href="#sec-5-1">5.1 States (<code>rfsm.composite_state</code> and <code>rfsm.simple_state</code>) </a>
<ul>
<li><a href="#sec-5-1-1">5.1.1 The doo function </a></li>
<li><a href="#sec-5-1-2">5.1.2 Particularities of the root composite state </a></li>
</ul>
</li>
<li><a href="#sec-5-2">5.2 Transitions (<code>rfsm.transition</code>) </a></li>
<li><a href="#sec-5-3">5.3 Connector (<code>rfsm.connector</code>) </a></li>
</ul>
</li>
<li><a href="#sec-6">6 Executing rFSM models </a></li>
<li><a href="#sec-7">7 API Summary </a>
<ul>
<li><a href="#sec-7-1">7.1 State specification </a></li>
<li><a href="#sec-7-2">7.2 Operational functions </a></li>
<li><a href="#sec-7-3">7.3 Hooks </a></li>
</ul>
</li>
<li><a href="#sec-8">8 Common pitfalls </a></li>
<li><a href="#sec-9">9 Tools and helper modules </a>
<ul>
<li><a href="#sec-9-1">9.1 The event memory extension (<code>rfsm_emem</code> module) </a></li>
<li><a href="#sec-9-2">9.2 Timeevents (<code>rfsm_timeevent</code> module) </a></li>
<li><a href="#sec-9-3">9.3 Configurable and colorized <code>dbg</code> info (<code>fsmpp</code> module) </a></li>
<li><a href="#sec-9-4">9.4 Generate graphical representations (<code>fsm2uml</code> and <code>fsm2dbg</code> modules) </a></li>
<li><a href="#sec-9-5">9.5 <code>rfsm-viz</code>: command line front end to fsm2uml/fsm2tree </a></li>
<li><a href="#sec-9-6">9.6 <code>rfsm-sim</code> simple rfsm simulator </a></li>
<li><a href="#sec-9-7">9.7 Lua fsm to json conversion (<code>rfsm2json</code> command line tool) </a></li>
<li><a href="#sec-9-8">9.8 <code>rfsm_rtt</code> Useful functions for using rFSM with OROCOS rtt </a></li>
</ul>
</li>
<li><a href="#sec-10">10 More examples, tips and tricks </a>
<ul>
<li><a href="#sec-10-1">10.1 A more complete example </a></li>
<li><a href="#sec-10-2">10.2 How to compose state machines </a></li>
<li><a href="#sec-10-3">10.3 Using rfsm with Orocos RTT </a></li>
</ul>
</li>
<li><a href="#sec-11">11 Contact </a></li>
<li><a href="#sec-12">12 Acknowledgement </a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Overview </h2>
<div class="outline-text-2" id="text-1">


<p>
  rFSM is a small and powerful Statechart implementation. It was
  mainly designed for <i>Coordinating</i> of complex systems but is not
  limited to that. rFSM is written in pure Lua and is therefore highly
  portable and embeddable. As a Lua domain specific language rFSM
  inherits the extensibility of its host language.
</p>
<p>
  rFSM is dual licensed under LGPL/BSD.
</p>
<p>
  This README is also available in HTML and Text format in the doc/
  subdirectory.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Setup </h2>
<div class="outline-text-2" id="text-2">


<p>
  Make sure you have Lua 5.1 installed and the rFSM folder is in your
  <code>LUA_PATH</code>. For example:
</p>



<pre class="src src-sh"><span style="color: #0000cd; font-weight: bold;">export</span> <span style="color: #cdcd00;">LUA_PATH</span>=<span style="color: #00cd00;">";;;/home/mk/src/git/rfsm/?.lua"</span>

</pre>




<p>
  If your <code>LUA_PATH</code> is already set to something, then just add the
  rFSM path instead of overwriting it:
</p>



<pre class="src src-sh"><span style="color: #0000cd; font-weight: bold;">export</span> <span style="color: #cdcd00;">LUA_PATH</span>=<span style="color: #00cd00;">"$LUA_PATH;/home/mk/src/git/rfsm/?.lua"</span>

</pre>




</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Quickstart </h2>
<div class="outline-text-2" id="text-3">


<ol>
<li>define an rfsm state machine (see <code>examples/hello_world.lua</code>)
</li>
<li>define a context script to execute it (see <code>examples/runscript.lua</code>)
</li>
<li>run it



<pre class="src src-sh">lua examples/runscript.lua
INFO: created undeclared connector root.initial
hello
world
hello
world

</pre>



</li>
</ol>


</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Introduction </h2>
<div class="outline-text-2" id="text-4">


<p>
  rFSM is minimal Statechart flavour designed for <i>Coordinating</i> of
  complex systems such as robots. It has the following features:
</p>
<ul>
<li>hierarchical (composite) states
</li>
<li>completion events
</li>
<li>States can be parametrized and reused
</li>
<li>It is easy to build statemachines by composing existing
    states/state machines.
</li>
<li>Plugin mechanism permits extending the core engine. Available
    plugins include timeevents, event memory, sequential AND states
    and more.
</li>
<li>real-time safe operation possible using lua-tlsf
</li>
</ul>


<p>
  The following shows a simple hello_world example
</p>


<p>
  <img src="example1.png"  alt="example1.png" />
</p>



<pre class="src src-lua"><span id="coderef-hello_fsm_root" class="coderef-off"><span class="linenr">1:  </span><span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.composite_state {</span>
<span id="coderef-hello_fsm_hello" class="coderef-off"><span class="linenr">2:  </span>   hello = rfsm.simple_state { <span style="color: #0000cd; font-weight: bold;">exit</span>=<span style="color: #00cdcd; font-weight: bold;">function</span>() print(<span style="color: #00cd00;">"hello"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span> },</span>
<span id="coderef-hello_fsm_world" class="coderef-off"><span class="linenr">3:  </span>   world = rfsm.simple_state { <span style="color: #0000cd; font-weight: bold;">entry</span>=<span style="color: #00cdcd; font-weight: bold;">function</span>() print(<span style="color: #00cd00;">"world"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span> },</span>
<span class="linenr">4:  </span>
<span id="coderef-hello_fsm_trans_ini" class="coderef-off"><span class="linenr">5:  </span>   rfsm.transition { src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'hello'</span> },</span>
<span id="coderef-hello_fsm_e_done" class="coderef-off"><span class="linenr">6:  </span>   rfsm.transition { src=<span style="color: #00cd00;">'hello'</span>, tgt=<span style="color: #00cd00;">'world'</span>, events={ <span style="color: #00cd00;">'e_done'</span> } },</span>
<span id="coderef-hello_fsm_e_restart" class="coderef-off"><span class="linenr">7:  </span>   rfsm.transition { src=<span style="color: #00cd00;">'world'</span>, tgt=<span style="color: #00cd00;">'hello'</span>, events={ <span style="color: #00cd00;">'e_restart'</span> } },</span>
<span class="linenr">8:  </span>}
<span class="linenr">9:  </span>
</pre>




<p>
  The <a href="#coderef-hello_fsm_root" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_root');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_root');">first line</a> defines a new toplevel composite state and returns
  it. The root state of an rFSM state machine is always a composite
  state. This permits it to be composed as a substate in a different
  state machine.. The <code>return</code> statement facilitates reading by tools
  or other state machines.
</p>
<p>
  The <a href="#coderef-hello_fsm_hello" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_hello');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_hello');">second</a> and <a href="#coderef-hello_fsm_world" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_world');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_world');">third</a> line define two simple states which are part of
  the toplevel composite state. <code>hello</code> defines an exit function and
  world an entry function which are called when the state is
  exited/entered resp.
</p>
<p>
  The next three lines define transition between these states. The
  <a href="#coderef-hello_fsm_trans_ini" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_trans_ini');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_trans_ini');">first</a> is from the initial connector to the <code>hello</code> state. This
  transition will be taken the first time the composite state is
  entered. The initial connector, as an exception, need not be defined
  and will be created automatically.
</p>
<p>
  The <a href="#coderef-hello_fsm_e_done" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_e_done');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_e_done');">next transition</a> is from <code>hello</code> to <code>world</code> and is triggered by
  the <code>e_done</code> event. This event is raised internally when a state
  completes, which is either the case when the states 'doo' function
  (see below) finishes or immediately, if there is no <code>doo</code>, as is the
  case here. The <a href="#coderef-hello_fsm_e_restart" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_e_restart');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_e_restart');">third transition</a> is triggered by the <code>e_restart</code>
  event.
</p>
<p>
  Next we execute this statemachine in the rfsm-simulator:
</p>



<pre class="src src-sh">PMA-10-048 ~/prog/lua/rfsm(master) $ tools/rfsm-sim examples/hello_world.lua
Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio
rFSM simulator v0.1, type <span style="color: #00cd00;">'help()'</span> to list available commands
INFO: created undeclared connector root.initial
&gt; step()
hello
active: root.hello(<span style="color: #00cdcd; font-weight: bold;">done</span>)
queue:  e_done@root.hello

</pre>




<p>
  We execute <code>step()</code> to advance the state machine once. As this is
  the first step, the fsm is entered via the 'initial' connector to
  the <code>hello</code> state. After that the state <code>hello</code> is active and <code>done</code>
  (because no <code>doo</code> function is defined). Consequently, an <code>e_done</code>
  completion event has been generated which is in the queue. So the
  next step&hellip;
</p>



<pre class="src src-sh">&gt; step()
world
active: root.world(<span style="color: #00cdcd; font-weight: bold;">done</span>)
queue:  e_done@root.world

</pre>




<p>
  &hellip; causes a transition to <code>world</code>. As the <code>world</code> state completion
  event does not trigger any transitons, running <code>step()</code> again does
  not cause any changes:
</p>



<pre class="src src-sh">&gt; step()
active: root.world(<span style="color: #00cdcd; font-weight: bold;">done</span>)
queue:

</pre>




<p>
  But we can manually send in the <code>e_restart</code> event and call <code>step()</code>,
  which takes us back to <code>hello</code>:
</p>



<pre class="src src-sh">&gt; se(<span style="color: #00cd00;">"e_restart"</span>)
&gt; step()
hello
active: root.hello(<span style="color: #00cdcd; font-weight: bold;">done</span>)
queue:  e_done@root.hello

</pre>





</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Specifying rFSM models </h2>
<div class="outline-text-2" id="text-5">


<p>
  rFSM state machines are built using the following four model
  elements: <b>composite_state</b>, <b>simple_state</b>, <b>connector</b> and
  <b>transition</b>.
</p>
<p>
  (all functions are part of the rfsm module, thus need to be called
  in Lua with the <code>rfsm</code> prefix, e.g. <code>rfsm.simple_state{}</code>)
</p>

</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> States (<code>rfsm.composite_state</code> and <code>rfsm.simple_state</code>) </h3>
<div class="outline-text-3" id="text-5-1">


<p>
   States can be either composite (<code>composite_state</code> or <code>csta</code>) or
   simple (<code>simple_state</code> or <code>sista</code>). While composite states may
   contain other composite or simple states, simple states are
   "leaves" of the FSM tree and can not contain any subtypes. Both
   simple and composite states may define <code>entry</code> and <code>exit</code> functions:
</p>



<pre class="src src-lua">entry(fsm, state, <span style="color: #00cd00;">'entry'</span>)
exit(fsm, state, <span style="color: #00cd00;">'exit'</span>)

</pre>




<p>
   that are called when the state is entered or exited
   respectively. The arguments passed in are the toplevel statechart,
   the current state and the string 'entry' resp. 'exit'. Normally
   you don't need these arguments and should not change them
   either. (The rationale behind the second and third argument is to
   permit one function to handle entry and exit of multiple states
   and hence needs to identify these).
</p>

</div>

<div id="outline-container-5-1-1" class="outline-4">
<h4 id="sec-5-1-1"><span class="section-number-4">5.1.1</span> The doo function </h4>
<div class="outline-text-4" id="text-5-1-1">


<p>
    Simple states may additionaly define a do function (it is called
    <code>doo</code> in rFSM to avoid clashes with the identically named Lua
    keyword).
</p>



<pre class="src src-lua">bool doo(fsm, state, <span style="color: #00cd00;">'doo'</span>)

</pre>




<p>
    The doo function is used to perform actions <i>while</i> a simple state
    is active. Therefore it can be used such that it is repeatedly
    called until either the function completes or an event triggers a
    transition to a different state.
</p>
<p>
    Implementationwise, this function is treated as a Lua
    coroutine. This enables the following two use-cases:
</p>
<ol>
<li><code>doo</code> is a regular function: <code>doo</code> is excuted once and a
        completion event <code>e_done</code> is raised afterwards (if no <code>doo</code>
        function is defined this event is raised immediately after
        execution of the <code>entry</code> function).

</li>
<li>long running <code>doo</code> with voluntary preemption: While possible,
        it is not recommended to define a <code>doo</code> function that runs for
        a longer time because this would prevent incoming events to
        trigger transitions. Therefore, the <code>rfsm.yield()</code> call can be
        inserted at appropriate points into a long running <code>doo</code> to
        explicitely return control to the rfsm engine, that then can
        check for new events and execute transitions.
</li>
</ol>


<p>
    (Note: rfsm.yield is currently only an alias to <code>coroutine.yield</code>)
</p>
<p>
    The following example illustrates the second use case:
</p>



<pre class="src src-lua"><span style="color: #0000cd; font-weight: bold;">doo</span> = <span style="color: #00cdcd; font-weight: bold;">function</span>(fsm)
         <span style="color: #00cdcd; font-weight: bold;">while</span> <span style="color: #00cdcd; font-weight: bold;">true</span> <span style="color: #00cdcd; font-weight: bold;">do</span>
            <span style="color: #00cdcd; font-weight: bold;">if</span> min_distance() &lt; 0.1 <span style="color: #00cdcd; font-weight: bold;">then</span>
               rfsm.send_events(fsm, <span style="color: #00cd00;">"e_close_obj"</span>)
            <span style="color: #00cdcd; font-weight: bold;">end</span>
            rfsm.yield()
         <span style="color: #00cdcd; font-weight: bold;">end</span>
      <span style="color: #00cdcd; font-weight: bold;">end</span>

</pre>




<p>
    This <code>doo</code> will check a certain condition repeatedly and raise
    an event if it is true. After that control is returned to the
    rFSM core.
</p>
<p>
    <code>rfsm.yield(idle_flag)</code> accepts a boolean argument (called the
    "idle flag") to influence the <code>doo</code> execution behavior by the rFSM
    core: if true it will cause the rFSM core to go idle if there are
    no other events. If false (the default if no argument given) and
    there are no other events, <code>doo</code> will be called in a tight
    loop. It depends on the application which idle<sub>flag</sub> is
    appropriate. In general the idle<sub>flag</sub> should only be true if the
    intention is that the <code>doo</code> function is executed as fast as
    possible, as this mode will consume a lot of CPU!
</p>
</div>

</div>

<div id="outline-container-5-1-2" class="outline-4">
<h4 id="sec-5-1-2"><span class="section-number-4">5.1.2</span> Particularities of the root composite state </h4>
<div class="outline-text-4" id="text-5-1-2">


<p>
    The root composite state allows some extra fields to define the
    global fsm behavior.
</p>
<p>    
    <b>Configuring error, warning, informational and debug output.</b> The
    <code>err</code>, <code>warn</code>, <code>info</code> and <code>dbg</code> fields can be used to fine tune
    how these messages are output. The value of these fields can be
    either true or false or set to a function that accepts a variable
    list of arguments. The default is to write errors and warnings to
    stderr and info to stdout. Debug messages are turned off by
    default. Nicer and configurable pretty printing of debug output is
    provided by the <code>fsmpp</code> module (described below).
</p>
<p>
    <b>The</b> <code>getevents</code> <b>hook.</b> The <code>getevents</code> hook is called by the
    rFSM core whenever it needs to check for new events. This function
    is the central mechanism to integrate rFSM into existing
    systems. The expected behavior is to return a Lua table of events
    (array part only). These events are then used to check for enabled
    transtions.
</p>
</div>
</div>

</div>

<div id="outline-container-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Transitions (<code>rfsm.transition</code>) </h3>
<div class="outline-text-3" id="text-5-2">


<p>
   Transitions define how a state machine changes state upon receiving
   events:
</p>
<p>
   Example:
</p>



<pre class="src src-lua">rfsm.transition { 
    src=<span style="color: #00cd00;">'stateX'</span>, tgt=<span style="color: #00cd00;">'stateY'</span>, events = {<span style="color: #00cd00;">"e1"</span>, <span style="color: #00cd00;">"e2"</span> },
    <span style="color: #0000cd; font-weight: bold;">guard</span>=<span style="color: #00cdcd; font-weight: bold;">function</span>() 
              <span style="color: #00cdcd; font-weight: bold;">if</span> getVal() &gt; 0.3 <span style="color: #00cdcd; font-weight: bold;">then</span>
                  <span style="color: #00cdcd; font-weight: bold;">return</span> <span style="color: #00cdcd; font-weight: bold;">false</span>
              <span style="color: #00cdcd; font-weight: bold;">end</span>
              <span style="color: #00cdcd; font-weight: bold;">return</span> <span style="color: #00cdcd; font-weight: bold;">true</span>
          <span style="color: #00cdcd; font-weight: bold;">end</span>,
    <span style="color: #0000cd; font-weight: bold;">effect</span>=<span style="color: #00cdcd; font-weight: bold;">function</span> () do_this() <span style="color: #00cdcd; font-weight: bold;">end</span>
}

</pre>




<p>
   The above defines a transition between stateX and stateY which is
   triggered by the events <code>e1</code> <span style="text-decoration:underline;">and</span> <code>e2</code>. The <code>guard</code> condition
   (optional) will prevent the transition from being executed if it
   returns false. The <code>effect</code> function (optional) will be executed
   during the transitioning of the function. If no events are
   specified this is interpreted as <b>any</b> events will trigger the
   transition.
</p>
<p>   
   Three ways of specifying <code>src</code> and <code>target</code> states are supported:
   <i>local</i>, <i>relative</i> or <i>absolute</i>. In the above example <code>stateX</code>
   and <code>stateY</code> are referenced locally and must therefore be defined
   within the same composite state as the transition.
</p>
<p>
   Relative references specify states which are, relative to the
   position of the transition, more deeply nested. Such a reference
   starts with a leading dot. For example:
</p>



<pre class="src src-lua"><span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.csta{
   operational=rfsm.csta{
      motors_on = rfsm.csta{
         moving = rfsm.sista{},
         stopped = rfsm.sista{},
         rfsm.trans{src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'stopped'</span>},
      },
      rfsm.trans{src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'motors_on'</span>},
   },
   off=rfsm.sista{},
<span id="coderef-trans_ref_types_one" class="coderef-off">   rfsm.trans{src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">".operational.motors_on.moving"</span> }</span>
<span id="coderef-trans_ref_types_two" class="coderef-off">   rfsm.trans{src=<span style="color: #00cd00;">".operational.motors_on.stopped"</span>, tgt=<span style="color: #00cd00;">'off'</span>, events={<span style="color: #00cd00;">'e_off'</span>} }</span>
}

</pre>




<p>
   The <a href="#coderef-trans_ref_types_one" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-trans_ref_types_one');" onmouseout="CodeHighlightOff(this, 'coderef-trans_ref_types_one');">first</a> transition is defined between the (locally referenced)
   <code>initial</code> connector to the relatively referenced <code>moving</code>
   state. This permits to <i>refine</i> the default behavior of the
   operational state, namely entering <code>motors_on.stopped</code> (due to the
   initial connectors), to instead enter the <code>motors_on.moving</code> state.
</p>
<p>
   The <a href="#coderef-trans_ref_types_two" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-trans_ref_types_two');" onmouseout="CodeHighlightOff(this, 'coderef-trans_ref_types_two');">second</a> transition defines a transition from the relatively
   referenced <code>operational.motors_on.stopped</code> to <code>off</code>. Here the
   intention is to constrain the states from which one can reach the
   <code>off</code> state: turning the device off is only permitted if it is not
   moving.
</p>
<p>
   At last absolute references begin with "root." Using absolute
   syntax is strongly discouraged for anything other than testing,
   as it breaks compositionality: if a state machine is used within
   a larger statemachine the absolute reference is broken.
</p>
<p>
   Furthermore, transitions support so called <b>priority    numbers</b>. Priority numbers serve to resolve conflicts within one
   hierarchical level. In case two transitions are enabled by a set of
   events, the transition with the higher priority number will be
   executed. Priority numbers are defined with the <code>pn</code> keyword on
   transitions, as shown below. Transitions without priority numbers
   are assumed to have priority 0.
</p>



<pre class="src src-lua">rfsm.trans{ src=<span style="color: #00cd00;">'following'</span>, tgt=<span style="color: #00cd00;">'hitting'</span>, pn=10, events={ <span style="color: #00cd00;">'t6'</span> } },

</pre>




<p>
   If possible, statecharts should be designed not to depend on
   priority numbers and introduce these rather as an optimization.
</p>
</div>

</div>

<div id="outline-container-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Connector (<code>rfsm.connector</code>) </h3>
<div class="outline-text-3" id="text-5-3">


<p>
   Connectors permit to define so called compound transitions by
   chaining multiple transition segments together. Connectors are
   similar to the UML junction element. Compound transitions are
   statically evaluated, meaning that the compound transition is only
   executed if each subtransition is enabled (events match and guards
   are true).
</p>
<p>
   See the examples <code>connector_simple.lua</code> and
   <code>connector_split.lua</code>.
</p>
<p>
   Connectors are useful for defining interfaces (entry and exit
   points) that hide internals of a composite state. The following
   example defines a error handling state:
</p>


<pre class="src src-lua"><span class="linenr"> 1:  </span><span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.csta{
<span class="linenr"> 2:  </span>  software_err = rfsm.sista{},
<span class="linenr"> 3:  </span>  hardware_err = rfsm.sista{},
<span class="linenr"> 4:  </span>
<span class="linenr"> 5:  </span>  initial = rfsm.conn{},     <span style="color: #cd0000;">-- </span><span style="color: #cd0000;">not necessary, 'initial' is created automatically</span>
<span class="linenr"> 6:  </span>  recovered = rfsm.conn{},
<span class="linenr"> 7:  </span>  failed = rfsm.conn{},
<span class="linenr"> 8:  </span>
<span id="coderef-conn_dispatch_dispatch1" class="coderef-off"><span class="linenr"> 9:  </span>  rfsm.trans{src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'software_err'</span>, events={<span style="color: #00cd00;">'e_sw_err'</span>}},</span>
<span id="coderef-conn_dispatch_dispatch2" class="coderef-off"><span class="linenr">10:  </span>  rfsm.trans{src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'hardware_err'</span>, events={<span style="color: #00cd00;">'e_hw_err'</span>}},</span>
<span class="linenr">11:  </span>
<span id="coderef-conn_dispatch_accept1" class="coderef-off"><span class="linenr">12:  </span>  rfsm.trans{src=<span style="color: #00cd00;">'software_err'</span>, tgt=<span style="color: #00cd00;">'recovered'</span>, events={<span style="color: #00cd00;">'e_recovered'</span>}},</span>
<span id="coderef-conn_dispatch_accept2" class="coderef-off"><span class="linenr">13:  </span>  rfsm.trans{src=<span style="color: #00cd00;">'hardware_err'</span>, tgt=<span style="color: #00cd00;">'recovered'</span>, events={<span style="color: #00cd00;">'e_recovered'</span>}},</span>
<span id="coderef-conn_dispatch_accept3" class="coderef-off"><span class="linenr">14:  </span>  rfsm.trans{src=<span style="color: #00cd00;">'software_err'</span>, tgt=<span style="color: #00cd00;">'failed'</span>, events={<span style="color: #00cd00;">'e_failed'</span>}},</span>
<span id="coderef-conn_dispatch_accept4" class="coderef-off"><span class="linenr">15:  </span>  rfsm.trans{src=<span style="color: #00cd00;">'hardware_err'</span>, tgt=<span style="color: #00cd00;">'failed'</span>, events={<span style="color: #00cd00;">'e_failed'</span>}},</span>
<span class="linenr">16:  </span>}
<span class="linenr">17:  </span>
</pre>




<p>
   Transitions <a href="#coderef-conn_dispatch_dispatch1" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-conn_dispatch_dispatch1');" onmouseout="CodeHighlightOff(this, 'coderef-conn_dispatch_dispatch1');">1</a> and <a href="#coderef-conn_dispatch_dispatch2" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-conn_dispatch_dispatch2');" onmouseout="CodeHighlightOff(this, 'coderef-conn_dispatch_dispatch2');">2</a> dispatch to different error handling states
   based on the events received. Transitions <a href="#coderef-conn_dispatch_accept1" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-conn_dispatch_accept1');" onmouseout="CodeHighlightOff(this, 'coderef-conn_dispatch_accept1');">3</a>, <a href="#coderef-conn_dispatch_accept2" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-conn_dispatch_accept2');" onmouseout="CodeHighlightOff(this, 'coderef-conn_dispatch_accept2');">4</a>, <a href="#coderef-conn_dispatch_accept3" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-conn_dispatch_accept3');" onmouseout="CodeHighlightOff(this, 'coderef-conn_dispatch_accept3');">5</a> and <a href="#coderef-conn_dispatch_accept4" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-conn_dispatch_accept4');" onmouseout="CodeHighlightOff(this, 'coderef-conn_dispatch_accept4');">6</a> connect the
   states to different exit connectors based on the events they
   generate.
</p>
<p>
   <i>Note</i>: defining cycles is possible, but dangerous, unsupported and
   discouraged. It may make the yoghurt in your fridge grow fine grey
   beards.
</p>

</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Executing rFSM models </h2>
<div class="outline-text-2" id="text-6">


<p>
  Before running a statemachine must be initalized. This serves to
  validate the fsm model and transform the fsm to be suitable for
  execution. Initalization is done using the <code>rfsm.init(fsm)</code>
  function, that takes a (string) rfsm description as input and
  returns an initalized fsm. To load an rfsm from a file and initalize
  it, the <code>rfsm.load(filename)</code> function can be used:
</p>



<pre class="src src-lua">fsm = rfsm.init(rfsm.load(<span style="color: #00cd00;">"fsm.lua"</span>))

</pre>




<p>
  If the return value from <code>rfsm.init</code> is not <code>false</code>, initalization
  succeeded and the returned fsm can be run.
</p>
<p>
  The function <code>rfsm.step(fsm, n)</code> will attempt to step the given fsm
  for a maximum of <code>n</code> times. A <i>step</i> can be either the execution of
  a transition <span style="text-decoration:underline;">or</span> a single execution of the <code>doo</code> program. <code>step</code>
  will return either when the state machine is <i>idle</i> <span style="text-decoration:underline;">or</span> the given
  number of steps has been reached. The boolean return value indicates
  whether the fsm is idle (<code>true</code>) or the maximum amount of requested
  steps was reached (<code>false</code>).
</p>
<p>
  For each step the rfsm engine will invoke the <code>getevents</code> hook to
  retrieve new events and then reason about what to do ( which
  transition to execute or <code>doo</code>'s to run).
</p>
<p>
  When ommitted, the number of steps argument <code>n</code> to <code>rfsm.step</code>
  defaults to <b>1</b>.
</p>
<p>
  <code>rfsm.run(fsm)</code> calls <code>step</code> as long as the given fsm is not
  idle. Not idle means: there are either events in the queue or there
  is an active <code>doo</code> function that is <span style="text-decoration:underline;">not</span> idle.
</p>
<p>
  To directly send events to the fsm the function
  <code>rfsm.send_events(fsm, e1, e2, ...)</code> can be used. The first argument
  is the fsm to which all subsequent event arguments are sent to.
</p>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> API Summary </h2>
<div class="outline-text-2" id="text-7">


</div>

<div id="outline-container-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> State specification </h3>
<div class="outline-text-3" id="text-7-1">


<p>
   Functions to define rFSM:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left"><b>Function</b></th><th scope="col" class="left"><b>Short alias</b></th><th scope="col" class="left"><b>Description</b></th></tr>
</thead>
<tbody>
<tr><td class="left"><code>simple_state{}</code></td><td class="left"><code>sista{}</code></td><td class="left">create a simple state</td></tr>
<tr><td class="left"><code>composite_state{}</code></td><td class="left"><code>csta{}</code></td><td class="left">create a composite state</td></tr>
<tr><td class="left"><code>connector{}</code></td><td class="left"><code>conn{}</code></td><td class="left">create a connector</td></tr>
<tr><td class="left"><code>transition{}</code></td><td class="left"><code>trans{}</code></td><td class="left">create a transition</td></tr>
</tbody>
</table>




</div>

</div>

<div id="outline-container-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Operational functions </h3>
<div class="outline-text-3" id="text-7-2">


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left"><b>Function</b></th><th scope="col" class="left"><b>Description</b></th></tr>
</thead>
<tbody>
<tr><td class="left"><code>fsm rfsm.init(fsmmodel)</code></td><td class="left">create an inialized rfsm instance from model</td></tr>
<tr><td class="left"><code>idle rfsm.step(fsm, n)</code></td><td class="left">attempt to transition FSM n times. Default: once</td></tr>
<tr><td class="left"><code>rfsm.run(fsm)</code></td><td class="left">run FSM until it goes idle</td></tr>
<tr><td class="left"><code>rfsm.send_events(fsm, ...)</code></td><td class="left">send one or more events to internal rfsm event queue</td></tr>
</tbody>
</table>



</div>

</div>

<div id="outline-container-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> Hooks </h3>
<div class="outline-text-3" id="text-7-3">


<p>
   The following hook functions can be defined for a toplevel
   composite state and allow to refine various behavior of the state
   machine.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left"><b>Function</b></th><th scope="col" class="left"><b>Description</b></th></tr>
</thead>
<tbody>
<tr><td class="left"><code>dbg</code></td><td class="left">called to output debug information. Set to false to disable. Default false.</td></tr>
<tr><td class="left"><code>info</code></td><td class="left">called to output informational messages. Set to false to disable. Default stdout</td></tr>
<tr><td class="left"><code>warn</code></td><td class="left">called to output warnings. Set to false to disable. Default stderr.</td></tr>
<tr><td class="left"><code>err</code></td><td class="left">called to output errors. Set to false to disable. Default stderr.</td></tr>
<tr><td class="left"><code>table getevents()</code></td><td class="left">function which returns a table of new events which have occurred</td></tr>
</tbody>
</table>



<p>
   Low level hooks (not for normal use):
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left"><b>Function</b></th><th scope="col" class="left"><b>Description</b></th></tr>
</thead>
<tbody>
<tr><td class="left"><code>pre_step_hook(fsm)</code></td><td class="left">is called for each step (mostly for debugging purposes)</td></tr>
<tr><td class="left"><code>step_hook(fsm)</code></td><td class="left">called before for each step</td></tr>
<tr><td class="left"><code>idle_hook(fsm)</code></td><td class="left">called <b>instead</b> of returning from step/run functions</td></tr>
</tbody>
</table>



</div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Common pitfalls </h2>
<div class="outline-text-2" id="text-8">


<ol>
<li>Name clashes between state/connector names with reserved Lua
     keywords.

<p>
     This can be worked around by using the following syntax:
</p>



<pre class="src src-lua">[<span style="color: #00cd00;">'end'</span>] = rfsm.sista{...}

</pre>




</li>
<li>Executing functions accidentially

<p>
     It is a common mistake to execute externally defined functions
     instead of adding references to them:
</p>



<pre class="src src-lua">stateX = rfsm.sista{ entry = my_func() }

</pre>




<p>
     The (likely) mistake above is to execute my_func and assigning
     the result to entry instead of assigning my_func:
</p>



<pre class="src src-lua">stateX = rfsm.sista{ entry = my_func }

</pre>




<p>
     Of course the first example would be perfectly valid if
     my_func() returned a function as a result!
</p>
</li>
<li>Why doesn't my statemachine react if I send a completion event
     <code>e_done</code> from the outside?

<p>
     Short anwer: because it is a syntactic shortcut for the
     completion event <b>of the source state</b> of the transition which it
     is defined on. During initalization it is transformed to
     <code>e_done@fqn</code> (e.g. <code>e_root@root.stateA.stateB</code>) If you send in
     the expanded completion event it will work.
</p>
<p>
     Explanation: a completion event only makes sense in the context
     of a state which completed. Making the state which has completed
     explicit in the event avoids accidentially triggering a
     transition labeled with a higher priority completion event that
     has nothing to do with the current one.
</p>
<p>
     The same holds true for <code>rfsm_timeevent</code> based timeevents.
</p>
</li>
<li>My FSM is using up 100% CPU, what's wrong?

<p>     
     Most likely you have defined a long running <code>doo</code> function that
     does not call <code>rfsm.yield</code> with a <code>true</code> argument (the idle
     flag). Therefore the rFSM engine calls the <code>doo</code> function in a
     tight loop.
</p></li>
</ol>


</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Tools and helper modules </h2>
<div class="outline-text-2" id="text-9">



</div>

<div id="outline-container-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> The event memory extension (<code>rfsm_emem</code> module) </h3>
<div class="outline-text-3" id="text-9-1">


<p>
   This extension adds "memory" of occured events to an rFSM
   chart. This is done maintaining a table &lt;code&gt;emem&lt;/code&gt; for every
   state. The &lt;code&gt;emem&lt;/code&gt; table is cleared when a state is
   exited by setting all values to 0.
</p>
<p>
   This extension is useful to define transitions that are taken only
   after certain events have occured, but these do not necessarily
   occur within one step. Because the default behavior of rFSM is to
   drop events if nothing can be done, this information is lost.
</p>
<p>
   To enable event memory, all you need to do is load the <code>rfsm_emem</code>
   module. Checkout the <code>examples/emem_test.lua</code> for more details.
</p>
</div>

</div>

<div id="outline-container-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> Timeevents (<code>rfsm_timeevent</code> module) </h3>
<div class="outline-text-3" id="text-9-2">


<p>   
   This extension adds time events to rFSM. To enable time events,
   load the <code>rfsm_timeevent</code> module. Currently only relative (opposed
   to absolute) timeevents are supported. These can be specified on
   transitions using the following syntax:
</p>



<pre class="src src-lua">rfsm.trans{ src=<span style="color: #00cd00;">'A'</span>, tgt=<span style="color: #00cd00;">'B'</span>, events={ <span style="color: #00cd00;">'e_after(0.1)'</span> } },

</pre>




<p>
   The timeevent will be raised 100ms after state <code>A</code> was entered.
</p>
<p>
   The only requirement of a rfsm<sub>timeevents</sub> is that a <code>gettime</code>
   function is configured using the
   <code>rfsm_timeevent.set_gettime_hook(f)</code> function. This function is
   expected to return the current time in two return values: sec,
   nanosecs.
</p>
<p>
   An example can be found in <code>examples/timeevent.lua</code>
</p>
<p>
   <b>Warning:</b> these timeevents only work while the rfsm engine is
    running and can not magically wake up an idle fsm. Therefore this
    type of timeevents typically only makes sense for fsm that are
    "stepped" at a fixed frequency or that never go idle.
</p>

</div>

</div>

<div id="outline-container-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> Configurable and colorized <code>dbg</code> info (<code>fsmpp</code> module) </h3>
<div class="outline-text-3" id="text-9-3">


<p>
   The <code>fsmpp.gen_dbgcolor</code> function generates a configurable and
   colorful <code>dbg</code> hook.
</p>
<p>
   Usage:
</p>



<pre class="src src-lua">fsmpp.gen_dbgcolor(name, dbgids, defshow)

</pre>




<ul>
<li><code>name</code> is the (optional) string name to print prefixing the
       debug output
</li>
<li><code>dbgids</code> is a table that enables or disables certain dbg ids by
       setting them to true or false.
</li>
<li><code>defshow</code> (bool) defines wether debug id's not mentioned in the dbgids
       table are shown or not.
</li>
</ul>

<p>   Example:
</p>



<pre class="src src-lua">fsm = rfsm.init(...)
fsm.dbg=fsmpp.gen_dbgcolor(<span style="color: #00cd00;">"my fsm"</span>, { STATE_ENTER=<span style="color: #00cdcd; font-weight: bold;">true</span>, STATE_EXIT=<span style="color: #00cdcd; font-weight: bold;">true</span> }, <span style="color: #00cdcd; font-weight: bold;">false</span>)

</pre>




<p>
   Will show only <code>STATE_ENTER</code> and <code>STATE_EXIT</code> dbg messages.
</p>
</div>

</div>

<div id="outline-container-9-4" class="outline-3">
<h3 id="sec-9-4"><span class="section-number-3">9.4</span> Generate graphical representations (<code>fsm2uml</code> and <code>fsm2dbg</code> modules) </h3>
<div class="outline-text-3" id="text-9-4">


<p>     
     Modules to transform rFSM models to graphical
     descriptions. <code>fsm2uml</code> generates classical statechart figures and
     <code>fsm2tree</code> generates a tree representation (useful to see check
     priorities).
</p>
<p>
     Usage: 
</p>
<ul>
<li><code>fsm2uml.fsm2uml(root_fsm, format, outfile, caption)</code>
</li>
<li><code>fsm2tree.fsm2tree(root_fsm, format, outfile)</code>
</li>
</ul>


<p>
     Examples:
</p>



<pre class="src src-lua">require(<span style="color: #00cd00;">"fsm2uml"</span>)
fsm = rfsm.init(rfsm.load(<span style="color: #00cd00;">"fsm.lua"</span>))
fsm2uml.fsm2uml(fsm, <span style="color: #00cd00;">'png'</span>, <span style="color: #00cd00;">"fsm.png"</span>, <span style="color: #00cd00;">"Figure caption"</span>)

</pre>




<p>
     or
</p>



<pre class="src src-lua">require(<span style="color: #00cd00;">"fsm2tree"</span>)
fsm = rfsm.init(rfsm.load(<span style="color: #00cd00;">"fsm.lua"</span>))
fsm2tree.fsm2tree(fsm, <span style="color: #00cd00;">'png'</span>, <span style="color: #00cd00;">"fsm-tree.png"</span>)

</pre>




<p>
     The <code>rfsm-viz</code> command line uses these modules to generate
     pictures.
</p>
</div>

</div>

<div id="outline-container-9-5" class="outline-3">
<h3 id="sec-9-5"><span class="section-number-3">9.5</span> <code>rfsm-viz</code>: command line front end to fsm2uml/fsm2tree </h3>
<div class="outline-text-3" id="text-9-5">


<p>
     to generate all possible formats run:
</p>



<pre class="src src-sh">$ tools/rfsm-viz all examples/composite_nested.lua

</pre>




<p>
     generates various representations (in <code>examples/</code>)
</p>
</div>

</div>

<div id="outline-container-9-6" class="outline-3">
<h3 id="sec-9-6"><span class="section-number-3">9.6</span> <code>rfsm-sim</code> simple rfsm simulator </h3>
<div class="outline-text-3" id="text-9-6">


<p>
     small command line simulator for running a fsm
     interactively.
</p>



<pre class="src src-sh">$ tools/rfsm-sim all examples/ball_tracker_scope.lua

</pre>




<p>
     It requires an image viewer which automatically updates once the
     file displayed changes. For example <code>evince</code> works nicely.
</p>
</div>

</div>

<div id="outline-container-9-7" class="outline-3">
<h3 id="sec-9-7"><span class="section-number-3">9.7</span> Lua fsm to json conversion (<code>rfsm2json</code> command line tool) </h3>
<div class="outline-text-3" id="text-9-7">


<p>
   Based on <code>rfsm2json.lua</code> module and requires lua-json.
</p>
</div>

</div>

<div id="outline-container-9-8" class="outline-3">
<h3 id="sec-9-8"><span class="section-number-3">9.8</span> <code>rfsm_rtt</code> Useful functions for using rFSM with OROCOS rtt </h3>
<div class="outline-text-3" id="text-9-8">


<p>   
   See the Orocos <a href="http://www.orocos.org/wiki/orocos/toolchain/LuaCookbook">LuaCookbook</a> for more details.
</p>
</div>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> More examples, tips and tricks </h2>
<div class="outline-text-2" id="text-10">


</div>

<div id="outline-container-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> A more complete example </h3>
<div class="outline-text-3" id="text-10-1">


<p>
   The graphical model:
</p>


<p>
   <img src="example2.png"  alt="example2.png" />
</p>
<p>
   &hellip; and the corresponding textual representation:
</p>



<pre class="src src-lua"><span style="color: #cd0000;">-- </span><span style="color: #cd0000;">any rFSM is always contained in a composite_state</span>
<span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.composite_state {
   dbg = <span style="color: #00cdcd; font-weight: bold;">true</span>, <span style="color: #cd0000;">-- </span><span style="color: #cd0000;">enable debugging</span>

   on = rfsm.composite_state {
      <span style="color: #0000cd; font-weight: bold;">entry</span> = <span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"disabling brakes"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span>,
      <span style="color: #0000cd; font-weight: bold;">exit</span> = <span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"enabling brakes"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span>,

      moving = rfsm.simple_state {
         <span style="color: #0000cd; font-weight: bold;">entry</span>=<span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"starting to move"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span>,
         <span style="color: #0000cd; font-weight: bold;">exit</span>=<span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"stopping"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span>,
      },

      waiting = rfsm.simple_state {},

      <span style="color: #cd0000;">-- </span><span style="color: #cd0000;">define some transitions</span>
      rfsm.trans{ src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'waiting'</span> },
      rfsm.trans{ src=<span style="color: #00cd00;">'waiting'</span>, tgt=<span style="color: #00cd00;">'moving'</span>, events={ <span style="color: #00cd00;">'e_start'</span> } },
      rfsm.trans{ src=<span style="color: #00cd00;">'moving'</span>, tgt=<span style="color: #00cd00;">'waiting'</span>, events={ <span style="color: #00cd00;">'e_stop'</span> } },
   },

   error = rfsm.simple_state {
      <span style="color: #0000cd; font-weight: bold;">doo</span> = <span style="color: #00cdcd; font-weight: bold;">function</span> (fsm)
                 print (<span style="color: #00cd00;">"Error detected - trying to fix"</span>)
                 rfsm.yield()
                 math.randomseed( os.time() )
                 rfsm.yield()
                 <span style="color: #00cdcd; font-weight: bold;">if</span> math.random(0,100) &lt; 40 <span style="color: #00cdcd; font-weight: bold;">then</span>
                    print(<span style="color: #00cd00;">"unable to fix, raising e_fatal_error"</span>)
                    rfsm.send_events(fsm, <span style="color: #00cd00;">"e_fatal_error"</span>)
                 <span style="color: #00cdcd; font-weight: bold;">else</span>
                    print(<span style="color: #00cd00;">"repair succeeded!"</span>)
                    rfsm.send_events(fsm, <span style="color: #00cd00;">"e_error_fixed"</span>)
                 <span style="color: #00cdcd; font-weight: bold;">end</span>
              <span style="color: #00cdcd; font-weight: bold;">end</span>,
   },

   fatal_error = rfsm.simple_state {},

   rfsm.trans{ src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'on'</span>, <span style="color: #0000cd; font-weight: bold;">effect</span>=<span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"initalizing system"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span> },
   rfsm.trans{ src=<span style="color: #00cd00;">'on'</span>, tgt=<span style="color: #00cd00;">'error'</span>, events={ <span style="color: #00cd00;">'e_error'</span> } },
   rfsm.trans{ src=<span style="color: #00cd00;">'error'</span>, tgt=<span style="color: #00cd00;">'on'</span>, events={ <span style="color: #00cd00;">'e_error_fixed'</span> } },
   rfsm.trans{ src=<span style="color: #00cd00;">'error'</span>, tgt=<span style="color: #00cd00;">'fatal_error'</span>, events={ <span style="color: #00cd00;">'e_fatal_error'</span> } },
   rfsm.trans{ src=<span style="color: #00cd00;">'fatal_error'</span>, tgt=<span style="color: #00cd00;">'initial'</span>, events={ <span style="color: #00cd00;">'e_reset'</span> } },
}

</pre>




</div>

</div>

<div id="outline-container-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> How to compose state machines </h3>
<div class="outline-text-3" id="text-10-2">


<p>
   This is easy! Let's assume the state machine is is a file
   "subfsm.lua" and uses the strongly recommended <code>return    rfsm.csta ...</code> syntax, it can be included as follows:
</p>



<pre class="src src-lua"><span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.csta {

   name_of_composite_state = rfsm.load(<span style="color: #00cd00;">"subfsm.lua"</span>),

   otherstateX = rfsm.sista{},
   ...
}

</pre>




<p>
   Make sure not to forget the ',' after the <code>rfsm.load()</code> statement!
</p>
</div>

</div>

<div id="outline-container-10-3" class="outline-3">
<h3 id="sec-10-3"><span class="section-number-3">10.3</span> Using rfsm with Orocos RTT </h3>
<div class="outline-text-3" id="text-10-3">

<p>   The <a href="http://www.orocos.org/wiki/orocos/toolchain/LuaCookbook">LuaCookbook</a> page describes how to do this.
</p></div>
</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> Contact </h2>
<div class="outline-text-2" id="text-11">


<p>
  Please direct questions, bugs or improvements to the <a href="http://lists.mech.kuleuven.be/mailman/listinfo/orocos-users">orocos-users</a>
  mailing list.
</p>
</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> Acknowledgement </h2>
<div class="outline-text-2" id="text-12">


<ul>
<li>Funding

<p>
    The research leading to these results has received funding from
    the European Community's Seventh Framework Programme
    (FP7/2007-2013) under grant agreement no. FP7-ICT-231940-BRICS
    (Best Practice in Robotics)
</p>
</li>
<li>Scientific background

<p>
    This work borrows many ideas from the Statecharts by David Harel
    and some from UML 2.1 State Machines. The following publications
    are the most relevant
</p>
<p>
    David Harel and Amnon Naamad. 1996. The STATEMATE semantics of
    statecharts. ACM Trans. Softw. Eng. Methodol. 5, 4 (October 1996),
    293-333. DOI=10.1145/235321.235322
    <a href="http://doi.acm.org/10.1145/235321.235322">http://doi.acm.org/10.1145/235321.235322</a>
</p>
<p>
    The OMG UML Specification:
    <a href="http://www.omg.org/spec/UML/2.3/Superstructure/PDF/">http://www.omg.org/spec/UML/2.3/Superstructure/PDF/</a>
</p></li>
</ul>

</div>
</div>
<div id="postamble">
<p class="date">Date: [2011-10-31 Mon]</p>
<p class="author">Author: Markus Klotzbuecher</p>
<p class="creator">Org version 7.6 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>
</div>
</div>
</body>
</html>
