<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>The rFSM Statecharts (v1.0-beta2)</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="[2011-05-03 Tue]"/>
<meta name="author" content="Markus Klotzbuecher"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/stylesheet.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="content">

<h1 class="title">The rFSM Statecharts (v1.0-beta2)</h1>



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Overview </a></li>
<li><a href="#sec-2">2 Setup </a></li>
<li><a href="#sec-3">3 Quickstart </a></li>
<li><a href="#sec-4">4 Introduction </a></li>
<li><a href="#sec-5">5 API </a>
<ul>
<li><a href="#sec-5_1">5.1 Model entities </a></li>
<li><a href="#sec-5_2">5.2 Operational API </a></li>
<li><a href="#sec-5_3">5.3 Hook functions </a></li>
</ul>
</li>
<li><a href="#sec-6">6 Common pitfalls </a></li>
<li><a href="#sec-7">7 Tools </a></li>
<li><a href="#sec-8">8 Helper modules </a></li>
<li><a href="#sec-9">9 More examples, tips and tricks </a>
<ul>
<li><a href="#sec-9_1">9.1 A more complete example </a></li>
<li><a href="#sec-9_2">9.2 How to compose state machines </a></li>
</ul>
</li>
<li><a href="#sec-10">10 Contact </a></li>
<li><a href="#sec-11">11 Acknowledgement </a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Overview </h2>
<div class="outline-text-2" id="text-1">


<p>
  rFSM is a small yet powerful Statechart implementation. It is mainly
  designed for <i>Coordinating</i> complex systems but is not limited to
  that. rFSM is written purely in Lua and is thus highly portable and
  embeddable. As a Lua domain specific language rFSM inherits the
  extensibility of its host language.
</p>
<p>
  rFSM is dual licensed under LGPL/BSD.
</p>
<p>
  This README is also available in HTML and Text format in the doc/
  subdirectory.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Setup </h2>
<div class="outline-text-2" id="text-2">


<p>
  Make sure the rFSM folder is in your <code>LUA_PATH</code>. For example:
</p>



<pre class="src src-sh"><span style="color: #0000cd; font-weight: bold;">export</span> <span style="color: #cdcd00;">LUA_PATH</span>=<span style="color: #00cd00;">";;;/home/mk/src/git/rfsm/?.lua"</span>
</pre>



</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Quickstart </h2>
<div class="outline-text-2" id="text-3">


<ol>
<li>define an rfsm state machine (see <code>examples/hello_world.lua</code>)
</li>
<li>define a context script to execute it (see <code>examples/runscript.lua</code>)
</li>
<li>run it



<pre class="src src-sh">lua examples/runscript.lua
INFO: created undeclared connector root.initial
hello
world
hello
world
</pre>


</li>
</ol>

</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Introduction </h2>
<div class="outline-text-2" id="text-4">


<p>
  rFSM is a minimal Statechart variant designed for <i>Coordinating</i>
  complex systems such as robots. It is written purely in Lua and is
  thus highly portable and embeddable. Being a Lua domain specific
  language, rFSM inherits the easy extensibility of its host language.
</p>
<p>
  The following shows a simple hello_world example
</p>

<p>
  <img src="example1.png"  alt="example1.png" />
</p>



<pre class="src src-lua"><span id="coderef-hello_fsm_root" class="coderef-off"><span class="linenr">1:  </span><span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.composite_state {</span>
<span id="coderef-hello_fsm_hello" class="coderef-off"><span class="linenr">2:  </span>   hello = rfsm.simple_state { <span style="color: #0000cd; font-weight: bold;">exit</span>=<span style="color: #00cdcd; font-weight: bold;">function</span>() print(<span style="color: #00cd00;">"hello"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span> },</span>
<span id="coderef-hello_fsm_world" class="coderef-off"><span class="linenr">3:  </span>   world = rfsm.simple_state { <span style="color: #0000cd; font-weight: bold;">entry</span>=<span style="color: #00cdcd; font-weight: bold;">function</span>() print(<span style="color: #00cd00;">"world"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span> },</span>
<span class="linenr">4:  </span>
<span id="coderef-hello_fsm_trans_ini" class="coderef-off"><span class="linenr">5:  </span>   rfsm.transition { src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'hello'</span> },</span>
<span id="coderef-hello_fsm_e_done" class="coderef-off"><span class="linenr">6:  </span>   rfsm.transition { src=<span style="color: #00cd00;">'hello'</span>, tgt=<span style="color: #00cd00;">'world'</span>, events={ <span style="color: #00cd00;">'e_done'</span> } },</span>
<span id="coderef-hello_fsm_e_restart" class="coderef-off"><span class="linenr">7:  </span>   rfsm.transition { src=<span style="color: #00cd00;">'world'</span>, tgt=<span style="color: #00cd00;">'hello'</span>, events={ <span style="color: #00cd00;">'e_restart'</span> } },</span>
<span class="linenr">8:  </span>}
</pre>



<p>
  The <a href="coderef:" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_root');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_root');">first line</a> defines a new toplevel composite state and returns
  it. By always returning the fsm as the last statement in an rfsm
  file, it can be very easily read by tools or other state machines.
</p>
<p>
  The <a href="coderef:" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_hello');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_hello');">second</a> and <a href="coderef:" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_world');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_world');">third</a> line define two simple states which are part of
  the toplevel composite state. <code>hello</code> defines an exit function and
  world an entry function which are called when the state is
  exited/entered resp.
</p>
<p>
  The next three lines define transition between these states. The
  <a href="coderef:" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_trans_ini');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_trans_ini');">first</a> is from the initial connector to the hello state. This
  transition will be taken the first time the state machine is
  entered. The initial connector, as an exception, need not be defined
  and will be created automatically.
</p>
<p>
  The <a href="coderef:" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_e_done');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_e_done');">next transition</a> is from hello to world and is triggered by the
  <code>e_done</code> event. This event is raised internally when the a state
  completes, which is either the case when the states "doo" function
  (see below) finishes or immediately if there is no doo, as is the
  case here. The <a href="coderef:" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_e_restart');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_e_restart');">third transition</a> is triggered by the <code>e_restart</code>
  event.
</p>
<p>
  Next we execute this statemachine in the rfsm-simulator:
</p>



<pre class="src src-sh">PMA-10-048 ~/prog/lua/rfsm(master) $ tools/rfsm-sim examples/hello_world.lua
Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio
rFSM simulator v0.1, type <span style="color: #00cd00;">'help()'</span> to list available commands
INFO: created undeclared connector root.initial
&gt; step()
hello
active: root.hello(<span style="color: #00cdcd; font-weight: bold;">done</span>)
queue:  e_done@root.hello
</pre>



<p>
  We execute <code>step()</code> to advance the state machine once. As this is
  the first step, the fsm is entered via the 'initial' connector to
  the <code>hello</code> state. After that hello is active and <code>done</code> (because no
  doo function is defined). Consequently an <code>e_done</code> completion event
  has been generated which is in the queue. So the next step&hellip;
</p>



<pre class="src src-sh">&gt; step()
world
active: root.world(<span style="color: #00cdcd; font-weight: bold;">done</span>)
queue:  e_done@root.world
</pre>



<p>
  &hellip; causes a transtion to done. As the 'world' state completion
  event does not trigger any transitons, running <code>step()</code> again does
  not cause any changes:
</p>



<pre class="src src-sh">&gt; step()
active: root.world(<span style="color: #00cdcd; font-weight: bold;">done</span>)
queue:
</pre>


<p>
  But we can manually send in the <code>e_restart</code> event and call <code>step()</code>,
  which takes us back to <code>hello</code>:
</p>



<pre class="src src-sh">&gt; se(<span style="color: #00cd00;">"e_restart"</span>)
&gt; step()
hello
active: root.hello(<span style="color: #00cdcd; font-weight: bold;">done</span>)
queue:  e_done@root.hello
</pre>




</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> API </h2>
<div class="outline-text-2" id="text-5">


</div>

<div id="outline-container-5_1" class="outline-3">
<h3 id="sec-5_1"><span class="section-number-3">5.1</span> Model entities </h3>
<div class="outline-text-3" id="text-5_1">


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Function</th><th scope="col" class="left">short alias</th><th scope="col" class="left">description</th></tr>
</thead>
<tbody>
<tr><td class="left"><code>simple_state{}</code></td><td class="left"><code>sista{}</code></td><td class="left">create a simple state</td></tr>
<tr><td class="left"><code>composite_state{}</code></td><td class="left"><code>csta{}</code></td><td class="left">create a composite state</td></tr>
<tr><td class="left"><code>connector{}</code></td><td class="left"><code>conn{}</code></td><td class="left">create a connector</td></tr>
<tr><td class="left"><code>transition{}</code></td><td class="left"><code>trans{}</code></td><td class="left">create a transition</td></tr>
</tbody>
</table>


<p>
   (these functions are part of the rfsm module, thus can be called
   in Lua with <code>rfsm.simple_state{}</code>)
</p>
<ol>
<li>states

<p>
      States are either of type <code>simple_state</code> or <code>composite_state</code>
      and may define the following programs:
</p>



<pre class="src src-lua">entry(fsm, state, <span style="color: #00cd00;">'entry'</span>)
exit(fsm, state, <span style="color: #00cd00;">'exit'</span>)
</pre>



<p>
      which are called when the state is entered exited or exited
      respectively. The argument passed in are the toplevel
      statechart, the current state and the string 'entry'
      resp. 'exit'. (The rationale behind the third argument is to
      allow one function to handle entry and exit and thus to be able
      to identify which one is being called.)
</p>
<p>
      Simple states may additionaly define a do function (it is called
      <code>doo</code> in to avoid clashes with the identically named Lua
      keyword).
</p>



<pre class="src src-lua">bool doo(fsm, state, <span style="color: #00cd00;">'doo'</span>)
</pre>



<p>
      This function is treated as a Lua coroutine. This means if it is
      a function it will be excuted and a completion event <code>e_done</code>
      raised afterwards. In case there is an event which triggers an
      outgoing transition it will not be run and that transition will
      be taken instead.
</p>
<p>
      In many cases this function shall run for a longer period until
      some event occurs. To allow the rFSM core to check for events in
      between and possibly execute a transition, the doo function must
      give up control. This can be done by calling
</p>
<p>
      <code>rfsm.yield()</code>
</p>
<p>
      (Note: this currently only an alias to <code>coroutine.yield</code>)
</p>
<p>
      The following example illustrates this:
</p>



<pre class="src src-lua"><span style="color: #0000cd; font-weight: bold;">doo</span> = <span style="color: #00cdcd; font-weight: bold;">function</span>(fsm)
         <span style="color: #00cdcd; font-weight: bold;">while</span> <span style="color: #00cdcd; font-weight: bold;">true</span> <span style="color: #00cdcd; font-weight: bold;">do</span>
            <span style="color: #00cdcd; font-weight: bold;">if</span> min_distance() &lt; 0.1 <span style="color: #00cdcd; font-weight: bold;">then</span>
               rfsm.send_events(fsm, <span style="color: #00cd00;">"e_close_obj"</span>)
            <span style="color: #00cdcd; font-weight: bold;">end</span>
            rfsm.yield()
         <span style="color: #00cdcd; font-weight: bold;">end</span>
      <span style="color: #00cdcd; font-weight: bold;">end</span>
</pre>



<p>
      This <code>doo</code> will check a certain condition repeadedly and raise
      an event if it is true. After that control is returned to the
      rFSM core.
</p>
<p>
      An boolen idle flag can be return to the rFSM core by passing it
      as a parameter to <code>rfsm.yield</code>. If this flag is true then
      it will cause the rfsm core to go idle if there are no other
      events. Otherwise, if no value or false is returned and there
      are no other events, doo will be called in a tight loop.
</p>
</li>
<li>connector: <code>connector</code>

<p>
      Connectors allow to define so called compound transitions by
      chaining multiple transition segments together. Connectors are
      similar to the UML junction element and are statically
      checked. This means for a compound transition to be executed the
      events specified on all transitions must match the current set
      of events and the guards of all transitions must be true.
</p>
<p>
      See the examples <code>connector_simple.lua</code> and <code>connector_split.lua</code>
</p>
<p>
      Connectors are useful for defining common entry points which are
      later dispatched to various internal states.
</p>
<p>
      Note: defining cycles is possible, but dangerous, unsupported
      and discouraged.
</p>
</li>
<li>transitions: <code>transitions</code>

<p>
      Transitions define how the state machine changes states when
      events occur:
</p>
<p>
      example:
</p>



<pre class="src src-lua">rfsm.transition{ src=<span style="color: #00cd00;">'stateX'</span>,
                     tgt=<span style="color: #00cd00;">'stateY'</span>,
                     events = {<span style="color: #00cd00;">"e1"</span>, <span style="color: #00cd00;">"e2"</span> },
                     <span style="color: #0000cd; font-weight: bold;">effect</span>=<span style="color: #00cdcd; font-weight: bold;">function</span> () do_this() <span style="color: #00cdcd; font-weight: bold;">end</span> }
</pre>



<p>
      This defines a transition between stateX and stateY which is
      triggered by e1 <span style="text-decoration:underline;">and</span> e2 and which will execute the given effect
      function when transitioning.
</p>
<p>
      Three ways of specifying src and target states are supported:
      <i>local</i>, <i>relative</i> or <i>absolute</i>. In the above example 'stateX'
      and 'stateY' are referenced locally and must therefore be
      defined within the same composite state as this transition.
</p>
<p>
      Relative references specify states which are, relative to the
      position of the transition, deeper nested. Such a reference
      starts with a leading dot. For example:
</p>



<pre class="src src-lua"><span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.csta{
   operational=rfsm.csta{
      motors_on = rfsm.csta{
         moving = rfsm.sista{},
         stopped = rfsm.sista{},
      },
   },
   off=rfsm.sista{},
   rfsm.trans{src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">".operational.motors_on.moving"</span>}
}
</pre>



<p>
      This transition is defined between the (locally referenced)
      'initial' connector to the relatively referenced <code>moving</code> state.
</p>
<p>
      At last absolute references begin with "root." Using absolute
      syntax is strongly discouraged for anything other than testing,
      as it breaks compositionality: if a state machine is used within
      a larger statemachine the absolute reference is broken.
</p></li>
</ol>

</div>

</div>

<div id="outline-container-5_2" class="outline-3">
<h3 id="sec-5_2"><span class="section-number-3">5.2</span> Operational API </h3>
<div class="outline-text-3" id="text-5_2">


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Function</th><th scope="col" class="left">description</th></tr>
</thead>
<tbody>
<tr><td class="left"><code>fsm rfsm.init(fsmmodel)</code></td><td class="left">create an inialized rfsm instance from model</td></tr>
<tr><td class="left"><code>idle rfsm.step(fsm, n)</code></td><td class="left">attempt to transition FSM n times. Default: once</td></tr>
<tr><td class="left"><code>rfsm.run(fsm)</code></td><td class="left">run FSM until it goes idle</td></tr>
<tr><td class="left"><code>rfsm.send_events(fsm, ...)</code></td><td class="left">send one or more events to internal rfsm event queue</td></tr>
</tbody>
</table>



<p>
   The <code>step</code> will attempt to step the given initialized fsm for n
   times. A step can either be a transition or a single execution of
   the doo program. Step will return either when the state machine is
   idle or the number of steps has been reached. The Boolean return
   value is whether the fsm is idle or not.
</p>
<p>
   Invoking <code>run</code> will call step as long as the fsm is not idle. Not idle
   means: there are events in the queue or there is an active <code>doo</code>
   function which is not idle.
</p>
</div>

</div>

<div id="outline-container-5_3" class="outline-3">
<h3 id="sec-5_3"><span class="section-number-3">5.3</span> Hook functions </h3>
<div class="outline-text-3" id="text-5_3">


<p>
   The following hook functions can be defined for a toplevel
   composite state and allow to refine various behavior of the state
   machine.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">function</th><th scope="col" class="left">description</th></tr>
</thead>
<tbody>
<tr><td class="left"><code>dbg</code></td><td class="left">called to output debug information. Set to false to disable. Default false.</td></tr>
<tr><td class="left"><code>info</code></td><td class="left">called to output informational messages. Set to false to disable. Default stdout</td></tr>
<tr><td class="left"><code>warn</code></td><td class="left">called to output warnings. Set to false to disable. Default stderr.</td></tr>
<tr><td class="left"><code>err</code></td><td class="left">called to output errors. Set to false to disable. Default stderr.</td></tr>
<tr><td class="left"><code>table getevents()</code></td><td class="left">function which returns a table of new events which have occurred</td></tr>
<tr><td class="left"><code>dropevents(fsm, evtab)</code></td><td class="left">function is called with events which are discarded</td></tr>
<tr><td class="left"><code>step_hook(fsm)</code></td><td class="left">is called for each step (mostly for debugging purposes)</td></tr>
<tr><td class="left"><code>idle_hook(fsm)</code></td><td class="left">called <b>instead</b> of returning from step/run functions</td></tr>
</tbody>
</table>


<p>
   The most important function is <code>getevents</code>. The purpose of this
   function is return all events which occurred in a table. This allows
   to integrate rFSM instances into any event driven environment.
</p>
</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Common pitfalls </h2>
<div class="outline-text-2" id="text-6">


<ol>
<li>Name clashes between state/connector names with reserved Lua
     keywords.

<p>
     This can be worked around by using the following syntax:
</p>



<pre class="src src-lua">[<span style="color: #00cd00;">'end'</span>] = rfsm.sista{...}
</pre>



</li>
<li>Executing functions accidentially

<p>
     It is a common mistake to execute externally defined functions
     instead of adding references to them:
</p>



<pre class="src src-lua">stateX = rfsm.sista{ entry = my_func() }
</pre>



<p>
     The (likely) mistake above is to execute my_func and assigning
     the result to entry instead of assigning my_func:
</p>



<pre class="src src-lua">stateX = rfsm.sista{ entry = my_func }
</pre>



<p>
     Of course the first example would be perfectly valid if
     my_func() returned a function as a result!
</p></li>
</ol>

</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Tools </h2>
<div class="outline-text-2" id="text-7">


<p>
  Some useful tools to be found in the <code>tools/</code> directory.
</p>
<ul>
<li><code>rfsm-viz</code>
    simple tool which can generate images from state machines.

<p>
    to generate all possible formats run:
</p>



<pre class="src src-sh">$ tools/rfsm-viz all examples/composite_nested.lua
</pre>



<p>
    generates various representations (in examples/)
</p>
</li>
<li><code>rfsm-sim</code>

<p>
    small command line simulator for running a fsm
    interactively.
</p>



<pre class="src src-sh">$ tools/rfsm-sim all examples/ball_tracker_scope.lua
</pre>



<p>
    It requires a image viewer which automatically updates once the
    file displayed changes. For example <code>evince</code> works nicely.
</p>
</li>
<li><code>rfsm2json</code> converts an lua fsm to a json representation. Requires
    lua-json.

</li>
<li><code>rfsm-dbg</code> experimental. don't use.
</li>
</ul>

</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Helper modules </h2>
<div class="outline-text-2" id="text-8">

<ul>
<li><code>fsm2uml.lua</code> module to generate UML like figures from rFSM
</li>
<li><code>fsm2tree.lua</code> module to generate the tree structure of an rFSM instance
</li>
<li><code>fsmpp.lua</code> Lowlevel function used to improve the debug output.
</li>
<li><code>fsmtesting.lua</code> statemachine testing infrastructure.
</li>
<li><code>rfsm_rtt.lua</code> Useful functions for using rFSM with OROCOS rtt
</li>
<li><code>fsmdbg.lua</code> a remote debugger interface which is simply still too
    experimental to be even documented.
</li>
</ul>

</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> More examples, tips and tricks </h2>
<div class="outline-text-2" id="text-9">


</div>

<div id="outline-container-9_1" class="outline-3">
<h3 id="sec-9_1"><span class="section-number-3">9.1</span> A more complete example </h3>
<div class="outline-text-3" id="text-9_1">


<p>
   The graphical model:
</p>

<p>
   <img src="example2.png"  alt="example2.png" />
</p>
<p>
   &hellip; and the corresponding textual representation:
</p>



<pre class="src src-lua"><span style="color: #cd0000;">-- </span><span style="color: #cd0000;">any rFSM is always contained in a composite_state
</span><span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.composite_state {
   dbg = <span style="color: #00cdcd; font-weight: bold;">true</span>, <span style="color: #cd0000;">-- </span><span style="color: #cd0000;">enable debugging
</span>
   on = rfsm.composite_state {
      <span style="color: #0000cd; font-weight: bold;">entry</span> = <span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"disabling brakes"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span>,
      <span style="color: #0000cd; font-weight: bold;">exit</span> = <span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"enabling brakes"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span>,

      moving = rfsm.simple_state {
         <span style="color: #0000cd; font-weight: bold;">entry</span>=<span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"starting to move"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span>,
         <span style="color: #0000cd; font-weight: bold;">exit</span>=<span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"stopping"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span>,
      },

      waiting = rfsm.simple_state {},

      <span style="color: #cd0000;">-- </span><span style="color: #cd0000;">define some transitions
</span>      rfsm.trans{ src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'waiting'</span> },
      rfsm.trans{ src=<span style="color: #00cd00;">'waiting'</span>, tgt=<span style="color: #00cd00;">'moving'</span>, events={ <span style="color: #00cd00;">'e_start'</span> } },
      rfsm.trans{ src=<span style="color: #00cd00;">'moving'</span>, tgt=<span style="color: #00cd00;">'waiting'</span>, events={ <span style="color: #00cd00;">'e_stop'</span> } },
   },

   error = rfsm.simple_state {
      <span style="color: #0000cd; font-weight: bold;">doo</span> = <span style="color: #00cdcd; font-weight: bold;">function</span> (fsm)
                 print (<span style="color: #00cd00;">"Error detected - trying to fix"</span>)
                 rfsm.yield()
                 math.randomseed( os.time() )
                 rfsm.yield()
                 <span style="color: #00cdcd; font-weight: bold;">if</span> math.random(0,100) &lt; 40 <span style="color: #00cdcd; font-weight: bold;">then</span>
                    print(<span style="color: #00cd00;">"unable to fix, raising e_fatal_error"</span>)
                    rfsm.send_events(fsm, <span style="color: #00cd00;">"e_fatal_error"</span>)
                 <span style="color: #00cdcd; font-weight: bold;">else</span>
                    print(<span style="color: #00cd00;">"repair succeeded!"</span>)
                    rfsm.send_events(fsm, <span style="color: #00cd00;">"e_error_fixed"</span>)
                 <span style="color: #00cdcd; font-weight: bold;">end</span>
              <span style="color: #00cdcd; font-weight: bold;">end</span>,
   },

   fatal_error = rfsm.simple_state {},

   rfsm.trans{ src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'on'</span>, <span style="color: #0000cd; font-weight: bold;">effect</span>=<span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"initalizing system"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span> },
   rfsm.trans{ src=<span style="color: #00cd00;">'on'</span>, tgt=<span style="color: #00cd00;">'error'</span>, events={ <span style="color: #00cd00;">'e_error'</span> } },
   rfsm.trans{ src=<span style="color: #00cd00;">'error'</span>, tgt=<span style="color: #00cd00;">'on'</span>, events={ <span style="color: #00cd00;">'e_error_fixed'</span> } },
   rfsm.trans{ src=<span style="color: #00cd00;">'error'</span>, tgt=<span style="color: #00cd00;">'fatal_error'</span>, events={ <span style="color: #00cd00;">'e_fatal_error'</span> } },
   rfsm.trans{ src=<span style="color: #00cd00;">'fatal_error'</span>, tgt=<span style="color: #00cd00;">'initial'</span>, events={ <span style="color: #00cd00;">'e_reset'</span> } },
}
</pre>



</div>

</div>

<div id="outline-container-9_2" class="outline-3">
<h3 id="sec-9_2"><span class="section-number-3">9.2</span> How to compose state machines </h3>
<div class="outline-text-3" id="text-9_2">


<p>
   This is easy! Let's assume the state machine is is a file
   "subfsm.lua" and uses the strongly recommended <code>return    rfsm.csta ...</code> syntax, it can be included as follows:
</p>



<pre class="src src-lua"><span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.csta {

   name_of_composite_state = rfsm.load(<span style="color: #00cd00;">"subfsm.lua"</span>),

   otherstateX = rfsm.sista{},
   ...
}
</pre>



<p>
   Make sure not to forget the ',' after the <code>rfsm.load()</code> statement!
</p>
</div>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Contact </h2>
<div class="outline-text-2" id="text-10">


<p>
  Please direct questions, bugs or improvements to the <a href="http://lists.mech.kuleuven.be/mailman/listinfo/orocos-users">orocos-users</a>
  mailing list.
</p>
</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> Acknowledgement </h2>
<div class="outline-text-2" id="text-11">


<ul>
<li>Funding

<p>
    The research leading to these results has received funding from
    the European Community's Seventh Framework Programme
    (FP7/2007-2013) under grant agreement no. FP7-ICT-231940-BRICS
    (Best Practice in Robotics)
</p>
</li>
<li>Scientific background

<p>
    This work borrows many ideas from the Statecharts by David Harel
    and some from UML 2.1 State Machines. The following publications
    are the most relevant
</p>
<p>
    David Harel and Amnon Naamad. 1996. The STATEMATE semantics of
    statecharts. ACM Trans. Softw. Eng. Methodol. 5, 4 (October 1996),
    293-333. DOI=10.1145/235321.235322
    <a href="http://doi.acm.org/10.1145/235321.235322">http://doi.acm.org/10.1145/235321.235322</a>
</p>
<p>
    The OMG UML Specification:
    <a href="http://www.omg.org/spec/UML/2.3/Superstructure/PDF/">http://www.omg.org/spec/UML/2.3/Superstructure/PDF/</a>
</p></li>
</ul>
</div>
</div>
<div id="postamble">
<p class="author">Author: Markus Klotzbuecher</p>
<p class="creator">Org version 7.5 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>
</div>
</div>
</body>
</html>
