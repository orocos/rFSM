<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title><img src="./rFSM_logo.jpg" width="71%" height="70%" title="rFSM Statecharts" alt="rFSM Statecharts" /@> <br/@><br/@>v1.0-beta5</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="<img src="./rFSM_logo.jpg" width="71%" height="70%" title="rFSM Statecharts" alt="rFSM Statecharts" /@> <br/@><br/@>v1.0-beta5"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-02-20"/>
<meta name="author" content="Markus Klotzbuecher"/>
<meta name="description" content="Documentation of rFSM Statecharts."/>
<meta name="keywords" content="Coordination, Statcharts, Robotics, Real-Time, Lua,"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/stylesheet.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title"><img src="./rFSM_logo.jpg" width="71%" height="70%" title="rFSM Statecharts" alt="rFSM Statecharts" /@> <br/@><br/@>v1.0-beta5</h1>



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Overview</a></li>
<li><a href="#sec-2">2 Setup</a></li>
<li><a href="#sec-3">3 Introduction</a></li>
<li><a href="#sec-4">4 Specifying rFSM models</a>
<ul>
<li><a href="#sec-4-1">4.1 States (<code>rfsm.state</code>)</a>
<ul>
<li><a href="#sec-4-1-1">4.1.1 The doo function</a></li>
<li><a href="#sec-4-1-2">4.1.2 Configuring a State Machine</a></li>
</ul>
</li>
<li><a href="#sec-4-2">4.2 Transitions (<code>rfsm.transition</code>)</a></li>
<li><a href="#sec-4-3">4.3 Connector (<code>rfsm.connector</code>)</a></li>
</ul>
</li>
<li><a href="#sec-5">5 Executing rFSM models</a></li>
<li><a href="#sec-6">6 Common pitfalls</a></li>
<li><a href="#sec-7">7 Tools and helper modules</a>
<ul>
<li><a href="#sec-7-1">7.1 The event memory extension (<code>rfsm_emem</code> module) #EventMemory</a></li>
<li><a href="#sec-7-2">7.2 Timeevents (<code>rfsm_timeevent</code> module)</a></li>
<li><a href="#sec-7-3">7.3 Configurable and colorized <code>dbg</code> info (<code>rfsmpp</code> module)</a></li>
<li><a href="#sec-7-4">7.4 <code>rfsm_checkevents</code> plugin</a></li>
<li><a href="#sec-7-5">7.5 Generate graphical representations (<code>rfsm2uml</code> and <code>fsm2dbg</code> modules)</a></li>
<li><a href="#sec-7-6">7.6 <code>rfsm-viz</code>: command line front end to rfsm2uml/rfsm2tree</a></li>
<li><a href="#sec-7-7">7.7 <code>rfsm-sim</code> simple rfsm simulator</a></li>
<li><a href="#sec-7-8">7.8 Lua fsm to json conversion (<code>rfsm2json</code> command line tool)</a></li>
<li><a href="#sec-7-9">7.9 <code>rfsm_rtt</code> Useful functions for using rFSM with OROCOS rtt</a></li>
</ul>
</li>
<li><a href="#sec-8">8 More examples, tips and tricks</a>
<ul>
<li><a href="#sec-8-1">8.1 A more complete example</a></li>
<li><a href="#sec-8-2">8.2 How to compose state machines</a></li>
<li><a href="#sec-8-3">8.3 Using rfsm with Orocos RTT</a></li>
</ul>
</li>
<li><a href="#sec-9">9 API Summary</a>
<ul>
<li><a href="#sec-9-1">9.1 State specification</a></li>
<li><a href="#sec-9-2">9.2 Operational functions</a></li>
<li><a href="#sec-9-3">9.3 Hooks</a></li>
</ul>
</li>
<li><a href="#sec-10">10 Contact</a></li>
<li><a href="#sec-11">11 Download</a></li>
<li><a href="#sec-12">12 Acknowledgement</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Overview</h2>
<div class="outline-text-2" id="text-1">


<p>
  rFSM is a small and powerful Statechart implementation. It is mainly
  designed for <i>Coordination</i> of complex systems but is not limited to
  that. rFSM is written in pure Lua and is therefore highly portable
  and embeddable. As a Lua domain specific language rFSM inherits the
  extensibility of its host language.
</p>
<p>
  rFSM is dual licensed under LGPL/BSD.
</p>
<p>
  This README is also available in HTML and Text format in the doc/
  subdirectory.
</p>

</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Setup</h2>
<div class="outline-text-2" id="text-2">


<p>
  Make sure you have Lua 5.1 installed and the rFSM folder is in your
  <code>LUA_PATH</code>. For example:
</p>



<pre class="src src-sh"><span style="color: #0000cd; font-weight: bold;">export</span> <span style="color: #cdcd00;">LUA_PATH</span>=<span style="color: #00cd00;">";;;/home/mk/src/git/rfsm/?.lua"</span>
</pre>


<p>
  If your <code>LUA_PATH</code> is already set to something, then just add the
  rFSM path instead of overwriting it:
</p>



<pre class="src src-sh"><span style="color: #0000cd; font-weight: bold;">export</span> <span style="color: #cdcd00;">LUA_PATH</span>=<span style="color: #00cd00;">"$LUA_PATH;/home/mk/src/git/rfsm/?.lua"</span>
</pre>



</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Introduction</h2>
<div class="outline-text-2" id="text-3">


<p>
  rFSM is minimal Statechart flavour designed for <i>Coordinating</i> of
  complex systems such as robots. It has the following features:
</p>
<ul>
<li>Hierarchical (composite) states
</li>
<li>Completion events
</li>
<li>Parametrizable and reusable states
</li>
<li>Easy to build statemachines by composing existing states/state machines
</li>
<li>Plugin mechanism permits extending the core engine. Available
    plugins include timeevents, event memory, sequential AND states
    and more.
</li>
<li>Real-time safe operation possible using lua-tlsf/rtp<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup>
</li>
</ul>


<p>
  The following shows a simple hello_world example
</p>


<p>
    <img src="example1.png"  alt="example1.png" />
</p>



<pre class="src src-lua"><span id="coderef-hello_fsm_root" class="coderef-off"><span class="linenr">1:  </span><span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.state {</span>
<span id="coderef-hello_fsm_hello" class="coderef-off"><span class="linenr">2:  </span>   hello = rfsm.state { <span style="color: #0000cd; font-weight: bold;">exit</span>=<span style="color: #00cdcd; font-weight: bold;">function</span>() print(<span style="color: #00cd00;">"hello"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span> },</span>
<span id="coderef-hello_fsm_world" class="coderef-off"><span class="linenr">3:  </span>   world = rfsm.state { <span style="color: #0000cd; font-weight: bold;">entry</span>=<span style="color: #00cdcd; font-weight: bold;">function</span>() print(<span style="color: #00cd00;">"world"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span> },</span>
<span class="linenr">4:  </span>
<span id="coderef-hello_fsm_trans_ini" class="coderef-off"><span class="linenr">5:  </span>   rfsm.transition { src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'hello'</span> },</span>
<span id="coderef-hello_fsm_e_done" class="coderef-off"><span class="linenr">6:  </span>   rfsm.transition { src=<span style="color: #00cd00;">'hello'</span>, tgt=<span style="color: #00cd00;">'world'</span>, events={ <span style="color: #00cd00;">'e_done'</span> } },</span>
<span id="coderef-hello_fsm_e_restart" class="coderef-off"><span class="linenr">7:  </span>   rfsm.transition { src=<span style="color: #00cd00;">'world'</span>, tgt=<span style="color: #00cd00;">'hello'</span>, events={ <span style="color: #00cd00;">'e_restart'</span> } },</span>
<span class="linenr">8:  </span>}
</pre>


<p>
  The <a href="#coderef-hello_fsm_root" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_root');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_root');">first line</a> defines a new toplevel composite state and returns
  it. The root state of an rFSM state machine is always a state
  itself. This permits it to be composed as a substate in a different
  state machine. The <code>return</code> statement facilitates reading rfsm model
  files by tools or other state machines.
</p>
<p>
  The <a href="#coderef-hello_fsm_hello" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_hello');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_hello');">second</a> and <a href="#coderef-hello_fsm_world" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_world');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_world');">third</a> line define two leaf states that are part of
  the toplevel composite state. <code>hello</code> defines an exit function and
  world an entry function which are called when the state is
  exited/entered, respectively.
</p>
<p>
  The next three lines define transition between these states. The
  <a href="#coderef-hello_fsm_trans_ini" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_trans_ini');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_trans_ini');">first</a> is from the initial connector to the <code>hello</code> state. This
  transition will be taken the first time the composite state is
  entered. The initial connector, as an exception, need not be defined
  and will be created automatically when referenced from a transition.
</p>
<p>
  The <a href="#coderef-hello_fsm_e_done" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_e_done');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_e_done');">next transition</a> is from <code>hello</code> to <code>world</code> and is triggered by
  the <code>e_done</code> event. This event is raised internally when a state
  completes, which is either the case when the states 'doo' function
  (see below) finishes or immediately, if there is no <code>doo</code>, as is the
  case here. The <a href="#coderef-hello_fsm_e_restart" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-hello_fsm_e_restart');" onmouseout="CodeHighlightOff(this, 'coderef-hello_fsm_e_restart');">third transition</a> is triggered by the <code>e_restart</code>
  event.
</p>
<p>
  Next we execute this statemachine in the rfsm-simulator:
</p>



<pre class="src src-sh">PMA-10-048 ~/prog/lua/rfsm(master) $ tools/rfsm-sim examples/hello_world.lua
Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio
rFSM simulator v0.1, type <span style="color: #00cd00;">'help()'</span> to list available commands
INFO: created undeclared connector root.initial
&gt; step()
hello
active: root.hello(<span style="color: #00cdcd; font-weight: bold;">done</span>)
queue:  e_done@root.hello
</pre>


<p>
  We execute <code>step()</code> to advance the state machine once. As this is
  the first step, the fsm is entered via the 'initial' connector to
  the <code>hello</code> state. After that the state <code>hello</code> is active and <code>done</code>
  (because no <code>doo</code> function is defined). Consequently, an <code>e_done</code>
  completion event has been generated and placed in the queue. So the
  next step&hellip;
</p>



<pre class="src src-sh">&gt; step()
world
active: root.world(<span style="color: #00cdcd; font-weight: bold;">done</span>)
queue:  e_done@root.world
</pre>


<p>
  &hellip; causes a transition to <code>world</code>. As the <code>world</code> state completion
  event does not trigger any transitons, running <code>step()</code> again does
  not have any effect:
</p>



<pre class="src src-sh">&gt; step()
active: root.world(<span style="color: #00cdcd; font-weight: bold;">done</span>)
queue:
</pre>


<p>
  But we can manually send in the <code>e_restart</code> event and call <code>step()</code>,
  which takes us back to <code>hello</code>:
</p>



<pre class="src src-sh">&gt; se(<span style="color: #00cd00;">"e_restart"</span>)
&gt; step()
hello
active: root.hello(<span style="color: #00cdcd; font-weight: bold;">done</span>)
queue:  e_done@root.hello
</pre>



</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Specifying rFSM models</h2>
<div class="outline-text-2" id="text-4">


<p>
  rFSM state machines are constructed using four model elements:
  <b>states</b>, <b>connectors</b> and <b>transitions</b>.
</p>
<p>
  (all functions are part of the rfsm module, thus need to be called
  in Lua with the <code>rfsm</code> prefix, e.g. <code>rfsm.state{}</code>)
</p>

</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> States (<code>rfsm.state</code>)</h3>
<div class="outline-text-3" id="text-4-1">


<p>
   States are used to model discrete states of the system and can be
   either composite or leaf states. A composite state contains other
   states, while a leaf state does not. States can define <code>entry</code> and
   <code>exit</code> functions
</p>



<pre class="src src-lua">entry(fsm, state, <span style="color: #00cd00;">'entry'</span>)
exit(fsm, state, <span style="color: #00cd00;">'exit'</span>)
</pre>


<p>
   that are called when the state is entered or exited
   respectively. The arguments passed in are the toplevel statechart,
   the current state and the string 'entry' resp. 'exit'. Normally
   you don't need these arguments and should not change them
   either. (The rationale behind the second and third argument is to
   permit one function to handle entry and exit of multiple states
   and hence needs to identify these).
</p>


</div>

<div id="outline-container-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> The doo function</h4>
<div class="outline-text-4" id="text-4-1-1">


<p>
    Leaf states may additionaly define a do function (it is called
    <code>doo</code> in rFSM to avoid clashes with the identically named Lua
    keyword).
</p>



<pre class="src src-lua">bool doo(fsm, state, <span style="color: #00cd00;">'doo'</span>)
</pre>


<p>
    The doo function is used to perform actions <i>while</i> a leaf state
    is active. To that end it can be used such that it is repeatedly
    called until either the function completes or an event triggers a
    transition to a different state.
</p>
<p>
    Implementationwise, this function is treated as a Lua
    coroutine. This enables the following two use-cases:
</p>
<ol>
<li><code>doo</code> is a regular function: <code>doo</code> is excuted once and a
        completion event <code>e_done</code> is raised afterwards (if no <code>doo</code>
        function is defined this event is raised immediately after
        execution of the <code>entry</code> function).

</li>
<li>Long running <code>doo</code> with voluntary preemption: while possible,
        it is not recommended to define a <code>doo</code> function that runs for
        a longer time, because this would prevent incoming events to
        trigger transitions. Therefore, the <code>rfsm.yield()</code> call can be
        inserted at appropriate points into a long running <code>doo</code> to
        explicitely return control to the rfsm engine, that then
        checks for new events and potentially executes transitions.
</li>
</ol>


<p>
    (Note: rfsm.yield is currently only an alias to <code>coroutine.yield</code>)
</p>
<p>
    The following example illustrates the second use case:
</p>



<pre class="src src-lua"><span style="color: #0000cd; font-weight: bold;">doo</span> = <span style="color: #00cdcd; font-weight: bold;">function</span>(fsm)
         <span style="color: #00cdcd; font-weight: bold;">while</span> <span style="color: #00cdcd; font-weight: bold;">true</span> <span style="color: #00cdcd; font-weight: bold;">do</span>
            <span style="color: #00cdcd; font-weight: bold;">if</span> min_distance() &lt; 0.1 <span style="color: #00cdcd; font-weight: bold;">then</span>
               rfsm.send_events(fsm, <span style="color: #00cd00;">"e_close_obj"</span>)
            <span style="color: #00cdcd; font-weight: bold;">end</span>
            rfsm.yield()
         <span style="color: #00cdcd; font-weight: bold;">end</span>
      <span style="color: #00cdcd; font-weight: bold;">end</span>
</pre>


<p>
    This <code>doo</code> will check a certain condition repeatedly and raise the
    "e_close_obj" event if it is true. Each cycle the control is
    returned to the rFSM core by calling <code>rfsm.yield()</code>.
</p>
<p>
    <code>rfsm.yield(idle_flag)</code> accepts a boolean argument (called the
    "idle flag") that influences how <code>doo</code> is called by the rFSM core:
    if <code>true</code> it will cause the rFSM core to go idle, provided there
    are no other events. If <code>false</code> (the default<sup><a class="footref" name="fnr.2" href="#fn.2">2</a></sup> if no arguments
    are given) and there are no other events, <code>doo</code> will be called in
    a tight loop. It depends on each application which <code>idle_flag</code> is
    appropriate. In general the idle_flag should always be true unless
    the intention is that the <code>doo</code> function is executed as fast as
    possible (potentially consuming a lot of CPU!).
</p>

</div>

</div>

<div id="outline-container-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> Configuring a State Machine</h4>
<div class="outline-text-4" id="text-4-1-2">


<p>
    The root composite state honors some extra fields to refine the
    global FSM behavior.
</p>
<p>
    <b>Configuring error, warning, informational and debug output.</b> The
    <code>err</code>, <code>warn</code>, <code>info</code> and <code>dbg</code> fields can be used to fine tune
    how these messages are output. The value of these fields can be
    either true or false or set to a function that accepts a variable
    list of arguments. The default is to write errors and warnings to
    stderr and info to stdout. Debug messages are turned off by
    default. Nicer and configurable pretty printing of debug output is
    provided by the <code>rfsmpp</code> module (described below).
</p>
<p>
    <b>The</b> <code>getevents</code> <b>hook.</b> The <code>getevents</code> hook is called by the
    rFSM core whenever it needs to check for new events. This function
    is the central mechanism to integrate rFSM into existing
    systems. The expected behavior is to return a Lua table of events
    (array part only). These events are then used to check for enabled
    transtions.
</p>
</div>
</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Transitions (<code>rfsm.transition</code>)</h3>
<div class="outline-text-3" id="text-4-2">


<p>
   Transitions define how a state machine changes state upon receiving
   events:
</p>
<p>
   Example:
</p>



<pre class="src src-lua">rfsm.transition {
    src=<span style="color: #00cd00;">'stateX'</span>, tgt=<span style="color: #00cd00;">'stateY'</span>, events = {<span style="color: #00cd00;">"e1"</span>, <span style="color: #00cd00;">"e2"</span>},
    <span style="color: #0000cd; font-weight: bold;">guard</span>=<span style="color: #00cdcd; font-weight: bold;">function</span>()
              <span style="color: #00cdcd; font-weight: bold;">if</span> getVal() &gt; 0.3 <span style="color: #00cdcd; font-weight: bold;">then</span>
                  <span style="color: #00cdcd; font-weight: bold;">return</span> <span style="color: #00cdcd; font-weight: bold;">false</span>
              <span style="color: #00cdcd; font-weight: bold;">end</span>
              <span style="color: #00cdcd; font-weight: bold;">return</span> <span style="color: #00cdcd; font-weight: bold;">true</span>
          <span style="color: #00cdcd; font-weight: bold;">end</span>,
    <span style="color: #0000cd; font-weight: bold;">effect</span>=<span style="color: #00cdcd; font-weight: bold;">function</span> () do_this() <span style="color: #00cdcd; font-weight: bold;">end</span>
}
</pre>


<p>
   The above defines a transition between stateX and stateY which is
   triggered by the events <code>e1</code> <span style="text-decoration:underline;">and</span> <code>e2</code>. The <code>guard</code> condition
   (optional) will prevent the transition from being executed if it
   returns false. The <code>effect</code> function (optional) will be executed
   during the transitioning of the function. If no events are
   specified, this is interpreted as <b>any</b> events will trigger the
   transition.
</p>
<p>
   Three ways of specifying the <code>src</code> and <code>target</code> states are
   supported: <i>local</i>, <i>relative</i> or <i>absolute</i>. In the above example
   <code>stateX</code> and <code>stateY</code> are referenced locally and must therefore be
   defined within the same composite state as the transition.
</p>
<p>
   Relative references specify states that are more deeply nested
   (relative to the position of the transition). Such references
   starts with a leading dot. For example:
</p>



<pre class="src src-lua"><span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.state{
   operational=rfsm.state{
      motors_on = rfsm.state{
         moving = rfsm.state{},
         stopped = rfsm.state{},
         rfsm.trans{src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'stopped'</span>},
      },
      rfsm.trans{src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'motors_on'</span>},
   },
   off=rfsm.state{},
<span id="coderef-trans_ref_types_one" class="coderef-off">   rfsm.trans{src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">".operational.motors_on.moving"</span> }</span>
<span id="coderef-trans_ref_types_two" class="coderef-off">   rfsm.trans{src=<span style="color: #00cd00;">".operational.motors_on.stopped"</span>, tgt=<span style="color: #00cd00;">'off'</span>, events={<span style="color: #00cd00;">'e_off'</span>} }</span>
}
</pre>


<p>
   The <a href="#coderef-trans_ref_types_one" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-trans_ref_types_one');" onmouseout="CodeHighlightOff(this, 'coderef-trans_ref_types_one');">first</a> transition is defined between the (locally referenced)
   <code>initial</code> connector to the relatively referenced <code>moving</code>
   state. This permits to <i>refine</i> the default behavior of the
   operational state, namely entering <code>motors_on.stopped</code> (due to the
   initial connectors), to instead enter the <code>motors_on.moving</code> state.
</p>
<p>
   The <a href="#coderef-trans_ref_types_two" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-trans_ref_types_two');" onmouseout="CodeHighlightOff(this, 'coderef-trans_ref_types_two');">second</a> transition defines a transition from the relatively
   referenced <code>operational.motors_on.stopped</code> to <code>off</code>. Here the
   intention is to constrain the states from which one can reach the
   <code>off</code> state: turning the device off is only permitted if it is not
   moving.
</p>
<p>
   At last absolute references begin with "root." Using absolute
   syntax is strongly discouraged for anything other than testing,
   as it breaks compositionality: if a state machine is used within
   a larger statemachine the absolute reference is broken.
</p>
<p>
   Furthermore, transitions support so called <b>priority    numbers</b>. Priority numbers serve to resolve conflicts within one
   hierarchical level. In case two transitions are enabled by a set of
   events, the transition with the higher priority number will be
   executed. Priority numbers are defined with the <code>pn</code> keyword on
   transitions, as shown below. Transitions without priority numbers
   are assumed to have priority 0.
</p>



<pre class="src src-lua">rfsm.trans{ src=<span style="color: #00cd00;">'following'</span>, tgt=<span style="color: #00cd00;">'hitting'</span>, pn=10, events={ <span style="color: #00cd00;">'t6'</span> } },
</pre>


<p>
   If possible, statecharts should be designed not to depend on
   priority numbers and introduce these rather as an optimization.
</p>
</div>

</div>

<div id="outline-container-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Connector (<code>rfsm.connector</code>)</h3>
<div class="outline-text-3" id="text-4-3">


<p>
   Connectors permit to define so called compound transitions by
   chaining multiple transition segments together. Connectors are
   similar to the UML junction element. Compound transitions are
   statically evaluated, meaning that the compound transition is only
   executed if each subtransition is enabled (events match and guards
   are true).
</p>
<p>
   Also see the examples <code>connector_simple.lua</code> and
   <code>connector_split.lua</code>.
</p>
<p>
   Connectors are useful for defining interfaces (entry and exit
   points) that hide internals of a composite state. The following
   example defines a error handling state:
</p>


<pre class="src src-lua"><span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.state{
  software_err = rfsm.state{},
  hardware_err = rfsm.state{},

  initial = rfsm.conn{},
  recovered = rfsm.conn{},
  failed = rfsm.conn{},

<span id="coderef-conn_dispatch_dispatch1" class="coderef-off">  rfsm.trans{src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'software_err'</span>, events={<span style="color: #00cd00;">'e_sw_err'</span>}},</span>
<span id="coderef-conn_dispatch_dispatch2" class="coderef-off">  rfsm.trans{src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'hardware_err'</span>, events={<span style="color: #00cd00;">'e_hw_err'</span>}},</span>

<span id="coderef-conn_dispatch_accept1" class="coderef-off">  rfsm.trans{src=<span style="color: #00cd00;">'software_err'</span>, tgt=<span style="color: #00cd00;">'recovered'</span>, events={<span style="color: #00cd00;">'e_recovered'</span>}},</span>
<span id="coderef-conn_dispatch_accept2" class="coderef-off">  rfsm.trans{src=<span style="color: #00cd00;">'hardware_err'</span>, tgt=<span style="color: #00cd00;">'recovered'</span>, events={<span style="color: #00cd00;">'e_recovered'</span>}},</span>
<span id="coderef-conn_dispatch_accept3" class="coderef-off">  rfsm.trans{src=<span style="color: #00cd00;">'software_err'</span>, tgt=<span style="color: #00cd00;">'failed'</span>, events={<span style="color: #00cd00;">'e_failed'</span>}},</span>
<span id="coderef-conn_dispatch_accept4" class="coderef-off">  rfsm.trans{src=<span style="color: #00cd00;">'hardware_err'</span>, tgt=<span style="color: #00cd00;">'failed'</span>, events={<span style="color: #00cd00;">'e_failed'</span>}},</span>
}
</pre>


<p>
   Transitions <a href="#coderef-conn_dispatch_dispatch1" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-conn_dispatch_dispatch1');" onmouseout="CodeHighlightOff(this, 'coderef-conn_dispatch_dispatch1');">1</a> and <a href="#coderef-conn_dispatch_dispatch2" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-conn_dispatch_dispatch2');" onmouseout="CodeHighlightOff(this, 'coderef-conn_dispatch_dispatch2');">2</a> dispatch to different error handling states
   based on the events received. Transitions <a href="#coderef-conn_dispatch_accept1" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-conn_dispatch_accept1');" onmouseout="CodeHighlightOff(this, 'coderef-conn_dispatch_accept1');">3</a>, <a href="#coderef-conn_dispatch_accept2" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-conn_dispatch_accept2');" onmouseout="CodeHighlightOff(this, 'coderef-conn_dispatch_accept2');">4</a>, <a href="#coderef-conn_dispatch_accept3" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-conn_dispatch_accept3');" onmouseout="CodeHighlightOff(this, 'coderef-conn_dispatch_accept3');">5</a> and <a href="#coderef-conn_dispatch_accept4" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-conn_dispatch_accept4');" onmouseout="CodeHighlightOff(this, 'coderef-conn_dispatch_accept4');">6</a> connect the
   states to different exit connectors based on the events they
   generate.
</p>
<p>
   <i>Note</i>: defining cycles is possible, but dangerous, unsupported and
   discouraged. It may make the yoghurt in your fridge grow fine grey
   beards.
</p>

</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Executing rFSM models</h2>
<div class="outline-text-2" id="text-5">


<p>
  Before running a statemachine must be initalized. This serves to
  validate the fsm model and transform the fsm to be suitable for
  execution. Initalization is done using the <code>rfsm.init(fsm)</code>
  function, that takes a (string) rfsm description as input and
  returns an initalized fsm. To load an rfsm from a file and initalize
  it, the <code>rfsm.load(filename)</code> function can be used:
</p>



<pre class="src src-lua">fsm = rfsm.init(rfsm.load(<span style="color: #00cd00;">"fsm.lua"</span>))
</pre>


<p>
  If the return value from <code>rfsm.init</code> is not <code>false</code>, initalization
  succeeded and the returned fsm can be run.
</p>
<p>
  The function <code>rfsm.step(fsm, n)</code> will attempt to step the given fsm
  for a maximum of <code>n</code> times. A <i>step</i> can be either the execution of
  a transition <span style="text-decoration:underline;">or</span> a single execution of the <code>doo</code> program. <code>step</code>
  will return either when the state machine is <i>idle</i> <span style="text-decoration:underline;">or</span> the given
  number of steps has been reached. The boolean return value indicates
  whether the fsm is idle (<code>true</code>) or the maximum amount of requested
  steps was reached (<code>false</code>).
</p>
<p>
  For each step the rfsm engine will invoke the <code>getevents</code> hook to
  retrieve new events and then reason about what to do (which
  transitions to execute or <code>doo</code>'s to run). After that these events
  are disgarded. If this seems inconvenient, checkout the <a href="#sec-7-1">event memory</a>
  extension.
</p>
<p>
  When omitted, the number of steps argument <code>n</code> to <code>rfsm.step</code>
  defaults to <b>1</b>.
</p>
<p>
  <code>rfsm.run(fsm)</code> calls <code>step</code> as long as the given fsm is not
  idle. Not idle means: there are either events in the queue or there
  is an active <code>doo</code> function that is <span style="text-decoration:underline;">not</span> idle.
</p>
<p>
  To directly send events to the fsm the function
  <code>rfsm.send_events(fsm, e1, e2, ...)</code> can be used. The first argument
  is the fsm to which all subsequent event arguments are sent to.
</p>

</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Common pitfalls</h2>
<div class="outline-text-2" id="text-6">


<ol>
<li>Name clashes between state/connector names with reserved Lua
     keywords.

<p>
     This can be worked around by using the following syntax:
</p>



<pre class="src src-lua">[<span style="color: #00cd00;">'end'</span>] = rfsm.state{...}
</pre>


</li>
<li>Executing functions accidentially

<p>
     It is a common mistake to execute externally defined functions
     instead of adding references to them:
</p>



<pre class="src src-lua">stateX = rfsm.state{ entry = my_func() }
</pre>


<p>
     The (likely) mistake above is to execute my_func and assigning
     the result to entry instead of assigning my_func:
</p>



<pre class="src src-lua">stateX = rfsm.state{ entry = my_func }
</pre>


<p>
     Of course the first example would be perfectly valid if
     my_func() returned a function as a result!
</p>
</li>
<li>Why doesn't my statemachine react if I send a completion event
     <code>e_done</code> from the outside?

<p>
     Short anwer: because it is a syntactic shortcut for the
     completion event <b>of the source state</b> of the transition which it
     is defined on. During initalization it is transformed to
     <code>e_done@fqn</code> (e.g. <code>e_root@root.stateA.stateB</code>) If you send in
     the expanded completion event it will work.
</p>
<p>
     Explanation: a completion event only makes sense in the context
     of a state which completed. Making the state which has completed
     explicit in the event avoids accidentially triggering a
     transition labeled with a higher priority completion event that
     has nothing to do with the current one.
</p>
<p>
     The same holds true for <code>rfsm_timeevent</code> based timeevents.
</p>
</li>
<li>My FSM is using up 100% CPU, what's wrong?

<p>
     Most likely you have defined a long running <code>doo</code> function that
     does not call <code>rfsm.yield</code> with a <code>true</code> argument (the idle
     flag). Therefore the rFSM engine calls the <code>doo</code> function in a
     tight loop.
</p></li>
</ol>



</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Tools and helper modules</h2>
<div class="outline-text-2" id="text-7">



</div>

<div id="outline-container-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> The event memory extension (<code>rfsm_emem</code> module) #<span class="target">EventMemory</span></h3>
<div class="outline-text-3" id="text-7-1">


<p>
   This extension adds <i>memory</i> of events that occured to an rFSM
   statechart. This is done maintaining a table <code>emem</code> for every
   state. The keys in this table are event names and the values the
   number of times that event occurred while the respective state was
   active. The <code>emem</code> table is cleared when a state is exited by
   setting all values to 0.
</p>
<p>
   This extension is useful for defining transitions that are taken
   only after certain events have occured, but that do not necessarily
   occur within one step. Because the rFSM engine drops events after
   each steps this information would otherwise be lost.
</p>
<p>
   To enable event memory, all you need to do is load the <code>rfsm_emem</code>
   module. Checkout the <code>examples/emem_test.lua</code> for more details.
</p>

</div>

</div>

<div id="outline-container-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Timeevents (<code>rfsm_timeevent</code> module)</h3>
<div class="outline-text-3" id="text-7-2">


<p>
   This module extends the rFSM engine with time events. Time events
   are automatically raised <i>after</i> the specified time after entering
   a state has elapsed. To enable time events, it suffices to load the
   <code>rfsm_timeevent</code> module. Currently only relative (opposed to
   absolute) timeevents are supported. These can be specified on
   transitions using the <code>e_done(duration)</code> syntax, as show in the
   following example:
</p>



<pre class="src src-lua">rfsm.trans{ src=<span style="color: #00cd00;">'A'</span>, tgt=<span style="color: #00cd00;">'B'</span>, events={ <span style="color: #00cd00;">'e_after(0.1)'</span> } },
</pre>


<p>
   The timeevent will be raised 100ms after state <code>A</code> was entered.
</p>
<p>
   The only requirement of a rfsm_timeevents is that a <code>gettime</code>
   function is configured using the
   <code>rfsm_timeevent.set_gettime_hook(f)</code> function. This function is
   expected to return the current time in two return values: seconds,
   nanoseconds.
</p>
<p>
   An example can be found in <code>examples/timeevent.lua</code>
</p>
<p>
   <b>Warning:</b> these timeevents only work while the rfsm engine is
    running and can not magically wake up an idle fsm. Therefore this
    type of timeevents typically only makes sense for fsm that are
    "stepped" at a fixed frequency or that never go idle.
</p>

</div>

</div>

<div id="outline-container-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> Configurable and colorized <code>dbg</code> info (<code>rfsmpp</code> module)</h3>
<div class="outline-text-3" id="text-7-3">


<p>
   The <code>rfsmpp.gen_dbgcolor</code> function generates a configurable and
   colorful <code>dbg</code> hook.
</p>
<p>
   Usage:
</p>



<pre class="src src-lua">rfsmpp.gen_dbgcolor(name, dbgids, defshow)
</pre>


<ul>
<li><code>name</code> is the (optional) string name to print prefixing the
       debug output
</li>
<li><code>dbgids</code> is a table that enables or disables certain dbg ids by
       setting them to true or false. Known debug ids are:
       <code>STATE_ENTER</code>, <code>STATE_EXIT</code>, <code>EFFECT</code>, <code>DOO</code>, <code>EXEC_PATH</code>,
       <code>ERROR</code>, <code>HIBERNATING</code>, <code>RAISED</code>, <code>TIMEEVENT</code>
</li>
<li><code>defshow</code> (bool) defines wether debug id's not mentioned in the dbgids
       table are shown or not.
</li>
</ul>



<p>
   Example:
</p>



<pre class="src src-lua">fsm = rfsm.init(...)
fsm.dbg=rfsmpp.gen_dbgcolor(<span style="color: #00cd00;">"fsm1"</span>,
                            { STATE_ENTER=<span style="color: #00cdcd; font-weight: bold;">true</span>, STATE_EXIT=<span style="color: #00cdcd; font-weight: bold;">true</span>}, <span style="color: #00cdcd; font-weight: bold;">false</span>)
</pre>


<p>
   Will show only <code>STATE_ENTER</code> and <code>STATE_EXIT</code> debug messages.
</p>
</div>

</div>

<div id="outline-container-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> <code>rfsm_checkevents</code> plugin</h3>
<div class="outline-text-3" id="text-7-4">


<p>
   This debugging helper plugin will at load-time construct a list of
   all events used in the FSM. If at runtime an event is received
   which is not known in the known list, a warning message will be
   printed.
</p>
<p>
   To use, just require the modeule before creating your
   fsm. Important: load it <i>after</i> other plugins that transform events
   (such as timevents), so that it picks up the transformed events.
</p>

</div>

</div>

<div id="outline-container-7-5" class="outline-3">
<h3 id="sec-7-5"><span class="section-number-3">7.5</span> Generate graphical representations (<code>rfsm2uml</code> and <code>fsm2dbg</code> modules)</h3>
<div class="outline-text-3" id="text-7-5">


<p>
     Modules to transform rFSM models to graphical
     descriptions. <code>rfsm2uml</code> generates classical statechart figures and
     <code>rfsm2tree</code> generates a tree representation (useful to see check
     priorities).
</p>
<p>
     Usage:
</p>
<ul>
<li><code>rfsm2uml.rfsm2uml(root_fsm, format, outfile, caption)</code>
</li>
<li><code>rfsm2tree.rfsm2tree(root_fsm, format, outfile)</code>
</li>
</ul>


<p>
     Examples:
</p>



<pre class="src src-lua">require(<span style="color: #00cd00;">"rfsm2uml"</span>)
fsm = rfsm.init(rfsm.load(<span style="color: #00cd00;">"fsm.lua"</span>))
rfsm2uml.rfsm2uml(fsm, <span style="color: #00cd00;">'png'</span>, <span style="color: #00cd00;">"fsm.png"</span>, <span style="color: #00cd00;">"Figure caption"</span>)
</pre>


<p>
     or
</p>



<pre class="src src-lua">require(<span style="color: #00cd00;">"rfsm2tree"</span>)
fsm = rfsm.init(rfsm.load(<span style="color: #00cd00;">"fsm.lua"</span>))
rfsm2tree.rfsm2tree(fsm, <span style="color: #00cd00;">'png'</span>, <span style="color: #00cd00;">"fsm-tree.png"</span>)
</pre>


<p>
     The <code>rfsm-viz</code> command line uses these modules to generate
     pictures.
</p>

</div>

</div>

<div id="outline-container-7-6" class="outline-3">
<h3 id="sec-7-6"><span class="section-number-3">7.6</span> <code>rfsm-viz</code>: command line front end to rfsm2uml/rfsm2tree</h3>
<div class="outline-text-3" id="text-7-6">


<p>
     to generate all possible formats run:
</p>



<pre class="src src-sh">$ tools/rfsm-viz all examples/composite_nested.lua
</pre>


<p>
     generates various representations (in <code>examples/</code>)
</p>

</div>

</div>

<div id="outline-container-7-7" class="outline-3">
<h3 id="sec-7-7"><span class="section-number-3">7.7</span> <code>rfsm-sim</code> simple rfsm simulator</h3>
<div class="outline-text-3" id="text-7-7">


<p>
     small command line simulator for running a fsm
     interactively.
</p>



<pre class="src src-sh">$ tools/rfsm-sim all examples/ball_tracker_scope.lua
</pre>


<p>
     It requires an image viewer which automatically updates once the
     file displayed changes. For example <code>evince</code> works nicely.
</p>

</div>

</div>

<div id="outline-container-7-8" class="outline-3">
<h3 id="sec-7-8"><span class="section-number-3">7.8</span> Lua fsm to json conversion (<code>rfsm2json</code> command line tool)</h3>
<div class="outline-text-3" id="text-7-8">


<p>
   Based on <code>rfsm2json.lua</code> module and requires lua-json.
</p>

</div>

</div>

<div id="outline-container-7-9" class="outline-3">
<h3 id="sec-7-9"><span class="section-number-3">7.9</span> <code>rfsm_rtt</code> Useful functions for using rFSM with OROCOS rtt</h3>
<div class="outline-text-3" id="text-7-9">


<p>
   See the Orocos <a href="http://www.orocos.org/wiki/orocos/toolchain/LuaCookbook">LuaCookbook</a> for more details.
</p>

</div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> More examples, tips and tricks</h2>
<div class="outline-text-2" id="text-8">



</div>

<div id="outline-container-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> A more complete example</h3>
<div class="outline-text-3" id="text-8-1">


<p>
   The graphical model:
</p>


<p>
      <img src="example2.png"  alt="example2.png" />
</p>
<p>
   &hellip; and the corresponding textual representation:
</p>



<pre class="src src-lua"><span style="color: #cd0000;">-- </span><span style="color: #cd0000;">any rFSM is always contained in a state</span>
<span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.state {
   dbg = <span style="color: #00cdcd; font-weight: bold;">true</span>, <span style="color: #cd0000;">-- </span><span style="color: #cd0000;">enable debugging</span>

   on = rfsm.state {
      <span style="color: #0000cd; font-weight: bold;">entry</span> = <span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"disabling brakes"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span>,
      <span style="color: #0000cd; font-weight: bold;">exit</span> = <span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"enabling brakes"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span>,

      moving = rfsm.state {
         <span style="color: #0000cd; font-weight: bold;">entry</span>=<span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"starting to move"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span>,
         <span style="color: #0000cd; font-weight: bold;">exit</span>=<span style="color: #00cdcd; font-weight: bold;">function</span> () print(<span style="color: #00cd00;">"stopping"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span>,
      },

      waiting = rfsm.state {},

      <span style="color: #cd0000;">-- </span><span style="color: #cd0000;">define some transitions</span>
      rfsm.trans{ src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'waiting'</span> },
      rfsm.trans{ src=<span style="color: #00cd00;">'waiting'</span>, tgt=<span style="color: #00cd00;">'moving'</span>, events={ <span style="color: #00cd00;">'e_start'</span> } },
      rfsm.trans{ src=<span style="color: #00cd00;">'moving'</span>, tgt=<span style="color: #00cd00;">'waiting'</span>, events={ <span style="color: #00cd00;">'e_stop'</span> } },
   },

   error = rfsm.state {
      <span style="color: #0000cd; font-weight: bold;">doo</span> = <span style="color: #00cdcd; font-weight: bold;">function</span> (fsm)
                 print (<span style="color: #00cd00;">"Error detected - trying to fix"</span>)
                 rfsm.yield()
                 math.randomseed( os.time() )
                 rfsm.yield()
                 <span style="color: #00cdcd; font-weight: bold;">if</span> math.random(0,100) &lt; 40 <span style="color: #00cdcd; font-weight: bold;">then</span>
                    print(<span style="color: #00cd00;">"unable to fix, raising e_fatal_error"</span>)
                    rfsm.send_events(fsm, <span style="color: #00cd00;">"e_fatal_error"</span>)
                 <span style="color: #00cdcd; font-weight: bold;">else</span>
                    print(<span style="color: #00cd00;">"repair succeeded!"</span>)
                    rfsm.send_events(fsm, <span style="color: #00cd00;">"e_error_fixed"</span>)
                 <span style="color: #00cdcd; font-weight: bold;">end</span>
              <span style="color: #00cdcd; font-weight: bold;">end</span>,
   },

   fatal_error = rfsm.state {},

   rfsm.trans{ src=<span style="color: #00cd00;">'initial'</span>, tgt=<span style="color: #00cd00;">'on'</span>,
               <span style="color: #0000cd; font-weight: bold;">effect</span>=<span style="color: #00cdcd; font-weight: bold;">function</span>() print(<span style="color: #00cd00;">"initalizing system"</span>) <span style="color: #00cdcd; font-weight: bold;">end</span> },
   rfsm.trans{ src=<span style="color: #00cd00;">'on'</span>, tgt=<span style="color: #00cd00;">'error'</span>, events={ <span style="color: #00cd00;">'e_error'</span> } },
   rfsm.trans{ src=<span style="color: #00cd00;">'error'</span>, tgt=<span style="color: #00cd00;">'on'</span>, events={ <span style="color: #00cd00;">'e_error_fixed'</span> } },
   rfsm.trans{ src=<span style="color: #00cd00;">'error'</span>, tgt=<span style="color: #00cd00;">'fatal_error'</span>, events={ <span style="color: #00cd00;">'e_fatal_error'</span> } },
   rfsm.trans{ src=<span style="color: #00cd00;">'fatal_error'</span>, tgt=<span style="color: #00cd00;">'initial'</span>, events={ <span style="color: #00cd00;">'e_reset'</span> } },
}
</pre>



</div>

</div>

<div id="outline-container-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> How to compose state machines</h3>
<div class="outline-text-3" id="text-8-2">


<p>
   This is easy! Let's assume the state machine is is a file
   "subfsm.lua" and uses the strongly recommended <code>return    rfsm.state ...</code> syntax, it can be included as follows:
</p>



<pre class="src src-lua"><span style="color: #00cdcd; font-weight: bold;">return</span> rfsm.state {

   name_of_state = rfsm.load(<span style="color: #00cd00;">"subfsm.lua"</span>),

   otherstateX = rfsm.state{},
   ...
}
</pre>


<p>
   Make sure not to forget the ',' after the <code>rfsm.load()</code> statement!
</p>

</div>

</div>

<div id="outline-container-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> Using rfsm with Orocos RTT</h3>
<div class="outline-text-3" id="text-8-3">

<p>   The <a href="http://www.orocos.org/wiki/orocos/toolchain/LuaCookbook">LuaCookbook</a> page describes how to do this.
</p>

</div>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> API Summary</h2>
<div class="outline-text-2" id="text-9">



</div>

<div id="outline-container-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> State specification</h3>
<div class="outline-text-3" id="text-9-1">


<p>
   Functions to define rFSM:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left"><b>Function</b></th><th scope="col" class="left"><b>Short alias</b></th><th scope="col" class="left"><b>Description</b></th></tr>
</thead>
<tbody>
<tr><td class="left"><code>state{}</code></td><td class="left"><code>state{}</code></td><td class="left">create a state</td></tr>
<tr><td class="left"><code>connector{}</code></td><td class="left"><code>conn{}</code></td><td class="left">create a connector</td></tr>
<tr><td class="left"><code>transition{}</code></td><td class="left"><code>trans{}</code></td><td class="left">create a transition</td></tr>
</tbody>
</table>




</div>

</div>

<div id="outline-container-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> Operational functions</h3>
<div class="outline-text-3" id="text-9-2">


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left"><b>Function</b></th><th scope="col" class="left"><b>Description</b></th></tr>
</thead>
<tbody>
<tr><td class="left"><code>fsm rfsm.init(fsmmodel)</code></td><td class="left">create an initialized rfsm instance from model</td></tr>
<tr><td class="left"><code>idle rfsm.step(fsm, n)</code></td><td class="left">attempt to transition FSM n times. Default: once</td></tr>
<tr><td class="left"><code>rfsm.run(fsm)</code></td><td class="left">run FSM until it goes idle</td></tr>
<tr><td class="left"><code>rfsm.send_events(fsm, ...)</code></td><td class="left">send one or more events to internal rfsm event queue</td></tr>
</tbody>
</table>



</div>

</div>

<div id="outline-container-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> Hooks</h3>
<div class="outline-text-3" id="text-9-3">


<p>
   The following hook functions can be defined for a toplevel
   composite state and allow to refine various behavior of the state
   machine.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left"><b>Function</b></th><th scope="col" class="left"><b>Description</b></th></tr>
</thead>
<tbody>
<tr><td class="left"><code>dbg</code></td><td class="left">called to output debug information. Set to false to disable. Default: false.</td></tr>
<tr><td class="left"><code>info</code></td><td class="left">called to output informational messages. Set to false to disable. Default: stdout.</td></tr>
<tr><td class="left"><code>warn</code></td><td class="left">called to output warnings. Set to false to disable. Default stderr.</td></tr>
<tr><td class="left"><code>err</code></td><td class="left">called to output errors. Set to false to disable. Default stderr.</td></tr>
<tr><td class="left"><code>table getevents()</code></td><td class="left">function which returns a table of new events which have occurred.</td></tr>
</tbody>
</table>



<p>
   Lower level functions (not for normal use):
</p>
<p>
   Use these to manage step hooks. Setting <code>pre_step_hook</code> and
   <code>post_step_hook</code> directly is not permitted anymore:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left"><b>Function</b></th><th scope="col" class="left"><b>Description</b></th></tr>
</thead>
<tbody>
<tr><td class="left"><code>pre_step_hook_add(fsm, hook, where)</code></td><td class="left">install function hook to be called <span style="text-decoration:underline;">before</span> each rfsm step of fsm</td></tr>
<tr><td class="left"><code>post_step_hook_add(fsm, hook, where)</code></td><td class="left">install function hook to be called <span style="text-decoration:underline;">after</span> each rfsm step of fsm</td></tr>
</tbody>
</table>


<p>
   <code>idle_hook(fsm)</code>: if defined, called <b>instead</b> of returning from
   step/run functions. Used only for debugging purposes.
</p>
</div>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Contact</h2>
<div class="outline-text-2" id="text-10">


<p>
  Please direct questions, bugs or improvements to the <a href="http://lists.mech.kuleuven.be/mailman/listinfo/orocos-users">orocos-users</a>
  mailing list.
</p>
</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> Download</h2>
<div class="outline-text-2" id="text-11">


<p>
  The code can be found in <a href="https://github.com/kmarkus/rFSM">this</a> git repository.
</p>
<p>  
  A cheatsheet summarizing the DSL is available <a href="https://github.com/kmarkus/rfsm-cheatsheet/raw/master/cheatsheet.pdf">here</a>.
</p>
</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> Acknowledgement</h2>
<div class="outline-text-2" id="text-12">


<ul>
<li>Funding

<p>
    The research leading to these results has received funding from
    the European Community's Seventh Framework Programme
    (FP7/2007-2013) under grant agreement no. FP7-ICT-231940-BRICS
    (Best Practice in Robotics)
</p>
</li>
<li>Scientific background

<p>
    This work borrows many ideas from the Statecharts by David Harel
    and some from UML 2.1 State Machines. The following publications
    are the most relevant
</p>
<p>
    David Harel and Amnon Naamad. 1996. The STATEMATE semantics of
    statecharts. ACM Trans. Softw. Eng. Methodol. 5, 4 (October 1996),
    293-333. DOI=10.1145/235321.235322
    <a href="http://doi.acm.org/10.1145/235321.235322">http://doi.acm.org/10.1145/235321.235322</a>
</p>
<p>
    The OMG UML Specification:
    <a href="http://www.omg.org/spec/UML/2.3/Superstructure/PDF/">http://www.omg.org/spec/UML/2.3/Superstructure/PDF/</a>
</p></li>
</ul>



<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> See <a href="https://lwn.net/images/conf/rtlws-2011/paper.05.html">this</a> Real-time Linux Workshop paper, <a href="https://github.com/kmarkus/lua-tlsf">lua-tlsf</a> and the
 <a href="https://github.com/kmarkus/rtp">minimal Lua real-time POSIX bindings</a>
</p>


<p class="footnote"><sup><a class="footnum" name="fn.2" href="#fnr.2">2</a></sup> The reason for this choice of default is that it fails more
  obviously (100% CPU load) than the opposite (doo function not
  executed properly).
</p></div>
</div>

</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-02-20</p>
<p class="author">Author: Markus Klotzbuecher</p>
<p class="creator">Org version 7.8.09 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
